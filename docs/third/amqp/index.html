<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>IoticAgent.third.amqp API documentation</title>
    <meta name="description" content="Low-level AMQP client for Python (fork of amqplib)" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #05B;
    text-decoration: none;
    font-weight: 500;
    border-bottom: 1px dashed #CCCCCC;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #E95420;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.AMQPNotImplementedError">AMQPNotImplementedError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.AMQPNotImplementedError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.AccessRefused">AccessRefused</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.AccessRefused.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.Channel">Channel</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.__init__">__init__</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_ack">basic_ack</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_cancel">basic_cancel</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_consume">basic_consume</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_get">basic_get</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_publish">basic_publish</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_publish_confirm">basic_publish_confirm</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_qos">basic_qos</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_recover">basic_recover</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_recover_async">basic_recover_async</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.basic_reject">basic_reject</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.close">close</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.confirm_select">confirm_select</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.dispatch_method">dispatch_method</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.exchange_bind">exchange_bind</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.exchange_declare">exchange_declare</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.exchange_delete">exchange_delete</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.exchange_unbind">exchange_unbind</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.flow">flow</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.queue_bind">queue_bind</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.queue_declare">queue_declare</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.queue_delete">queue_delete</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.queue_purge">queue_purge</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.queue_unbind">queue_unbind</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.tx_commit">tx_commit</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.tx_rollback">tx_rollback</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.tx_select">tx_select</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Channel.wait">wait</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ChannelError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ChannelNotOpen">ChannelNotOpen</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ChannelNotOpen.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.Connection">Connection</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.__init__">__init__</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.Transport">Transport</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.channel">channel</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.close">close</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.dispatch_method">dispatch_method</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.drain_events">drain_events</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.heartbeat_tick">heartbeat_tick</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.is_alive">is_alive</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.read_timeout">read_timeout</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.send_heartbeat">send_heartbeat</a></li>
    <li class="mono"><a href="#IoticAgent.third.amqp.Connection.wait">wait</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ConnectionError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ConnectionForced">ConnectionForced</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ConnectionForced.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ConsumerCancelled">ConsumerCancelled</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ConsumerCancelled.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ContentTooLarge">ContentTooLarge</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ContentTooLarge.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.FrameError">FrameError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.FrameError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.FrameSyntaxError">FrameSyntaxError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.FrameSyntaxError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.InternalError">InternalError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.InternalError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.InvalidCommand">InvalidCommand</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.InvalidCommand.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.InvalidPath">InvalidPath</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.InvalidPath.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.IrrecoverableChannelError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.Message">Message</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.Message.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.NoConsumers">NoConsumers</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.NoConsumers.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.NotAllowed">NotAllowed</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.NotAllowed.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.NotFound">NotFound</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.NotFound.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.PreconditionFailed">PreconditionFailed</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.PreconditionFailed.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.RecoverableChannelError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.RecoverableConnectionError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ResourceError">ResourceError</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ResourceError.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.ResourceLocked">ResourceLocked</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.ResourceLocked.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#IoticAgent.third.amqp.UnexpectedFrame">UnexpectedFrame</a></span>
        
          
  <ul>
    <li class="mono"><a href="#IoticAgent.third.amqp.UnexpectedFrame.__init__">__init__</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">IoticAgent.third.amqp</span> module</h1>
  <p>Low-level AMQP client for Python (fork of amqplib)</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp" class="source">
    <pre><code>"""Low-level AMQP client for Python (fork of amqplib)"""
# Copyright (C) 2007-2008 Barry Pederson <bp@barryp.org>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
from __future__ import absolute_import

VERSION = (1, 4, 7)
__version__ = '.'.join(map(str, VERSION[0:3])) + ''.join(VERSION[3:])
__author__ = 'Barry Pederson'
__maintainer__ = 'Ask Solem'
__contact__ = 'pyamqp@celeryproject.org'
__homepage__ = 'http://github.com/celery/py-amqp'
__docformat__ = 'restructuredtext'

# -eof meta-

#
# Pull in the public items from the various sub-modules
#
from .basic_message import Message      # noqa
from .channel import Channel            # noqa
from .connection import Connection      # noqa
from .exceptions import (               # noqa
    AMQPError,
    ConnectionError,
    RecoverableConnectionError,
    IrrecoverableConnectionError,
    ChannelError,
    RecoverableChannelError,
    IrrecoverableChannelError,
    ConsumerCancelled,
    ContentTooLarge,
    NoConsumers,
    ConnectionForced,
    InvalidPath,
    AccessRefused,
    NotFound,
    ResourceLocked,
    PreconditionFailed,
    FrameError,
    FrameSyntaxError,
    InvalidCommand,
    ChannelNotOpen,
    UnexpectedFrame,
    ResourceError,
    NotAllowed,
    AMQPNotImplementedError,
    InternalError,
    error_for_code,
    __all__ as _all_exceptions,
)
from .utils import promise  # noqa

__all__ = [
    'Connection',
    'Channel',
    'Message',
] + _all_exceptions
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.AMQPError" class="name">class <span class="ident">AMQPError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.AMQPError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.AMQPError" class="source">
    <pre><code>class AMQPError(Exception):
    code = 0

    def __init__(self, reply_text=None, method_sig=None,
                 method_name=None, reply_code=None):
        self.message = reply_text
        self.reply_code = reply_code or self.code
        self.reply_text = reply_text
        self.method_sig = method_sig
        self.method_name = method_name or ''
        if method_sig and not self.method_name:
            self.method_name = METHOD_NAME_MAP.get(method_sig, '')
        Exception.__init__(self, reply_code,
                           reply_text, method_sig, self.method_name)

    def __str__(self):
        if self.method:
            return '{0.method}: ({0.reply_code}) {0.reply_text}'.format(self)
        return self.reply_text or '<AMQPError: unknown error>'

    @property
    def method(self):
        return self.method_name or self.method_sig
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.AMQPError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.AMQPError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.AMQPError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.message" class="name">var <span class="ident">message</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.method" class="name">var <span class="ident">method</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.method_name" class="name">var <span class="ident">method_name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.method_sig" class="name">var <span class="ident">method_sig</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.reply_code" class="name">var <span class="ident">reply_code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPError.reply_text" class="name">var <span class="ident">reply_text</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.AMQPNotImplementedError" class="name">class <span class="ident">AMQPNotImplementedError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.AMQPNotImplementedError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.AMQPNotImplementedError" class="source">
    <pre><code>class AMQPNotImplementedError(IrrecoverableConnectionError):
    code = 540
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.AMQPNotImplementedError">AMQPNotImplementedError</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPNotImplementedError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPNotImplementedError.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.AMQPNotImplementedError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.AMQPNotImplementedError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.AMQPNotImplementedError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.AMQPNotImplementedError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.AccessRefused" class="name">class <span class="ident">AccessRefused</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.AccessRefused', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.AccessRefused" class="source">
    <pre><code>class AccessRefused(IrrecoverableChannelError):
    code = 403
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.AccessRefused">AccessRefused</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.AccessRefused.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.AccessRefused.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.AccessRefused.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.AccessRefused.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.AccessRefused.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.AccessRefused.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.Channel" class="name">class <span class="ident">Channel</span></p>
      
  
    <div class="desc"><p>Work with channels</p>
<p>The channel class provides methods for a client to establish a
virtual connection - a channel - to a server and for both peers to
operate the virtual connection thereafter.</p>
<p>GRAMMAR::</p>
<pre><code>channel             = open-channel *use-channel close-channel
open-channel        = C:OPEN S:OPEN-OK
use-channel         = C:FLOW S:FLOW-OK
                    / S:FLOW C:FLOW-OK
                    / functional-class
close-channel       = C:CLOSE S:CLOSE-OK
                    / S:CLOSE C:CLOSE-OK
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel" class="source">
    <pre><code>class Channel(AbstractChannel):
    """Work with channels

    The channel class provides methods for a client to establish a
    virtual connection - a channel - to a server and for both peers to
    operate the virtual connection thereafter.

    GRAMMAR::

        channel             = open-channel *use-channel close-channel
        open-channel        = C:OPEN S:OPEN-OK
        use-channel         = C:FLOW S:FLOW-OK
                            / S:FLOW C:FLOW-OK
                            / functional-class
        close-channel       = C:CLOSE S:CLOSE-OK
                            / S:CLOSE C:CLOSE-OK

    """

    def __init__(self, connection, channel_id=None, auto_encode_decode=True):
        """Create a channel bound to a connection and using the specified
        numeric channel_id, and open on the server.

        The 'auto_encode_decode' parameter (defaults to True), indicates
        whether the library should attempt to encode/decode the body
        of Messages to/from a Unicode string. The 'content_encoding' property
        of the message is used if set, otherwise encoding default to utf-8. If
        decode raises an Exception, the message body is left as plain bytes. If
        the input is not unicode, it is also left as-is.

        """
        if channel_id:
            connection._claim_channel_id(channel_id)
        else:
            channel_id = connection._get_free_channel_id()

        AMQP_LOGGER.debug('using channel_id: %d', channel_id)

        super(Channel, self).__init__(connection, channel_id)

        self.is_open = False
        self.active = True  # Flow control
        self.returned_messages = Queue()
        self.callbacks = {}
        self.cancel_callbacks = {}
        self.auto_encode_decode = auto_encode_decode
        self.events = defaultdict(set)
        self.no_ack_consumers = set()

        # set first time basic_publish_confirm is called
        # and publisher confirms are enabled for this channel.
        self._confirm_selected = False
        if self.connection.confirm_publish:
            self.basic_publish = self.basic_publish_confirm

        self._x_open()

    def _do_close(self):
        """Tear down this object, after we've agreed to close
        with the server."""
        AMQP_LOGGER.debug('Closed channel #%d', self.channel_id)
        self.is_open = False
        channel_id, self.channel_id = self.channel_id, None
        connection, self.connection = self.connection, None
        if connection:
            connection.channels.pop(channel_id, None)
            connection._avail_channel_ids.append(channel_id)
        self.callbacks.clear()
        self.cancel_callbacks.clear()
        self.events.clear()
        self.no_ack_consumers.clear()

    def _do_revive(self):
        self.is_open = False
        self._x_open()

    def close(self, reply_code=0, reply_text='', method_sig=(0, 0)):
        """Request a channel close

        This method indicates that the sender wants to close the
        channel. This may be due to internal conditions (e.g. a forced
        shut-down) or due to an error handling a specific method, i.e.
        an exception.  When a close is due to an exception, the sender
        provides the class and method id of the method which caused
        the exception.

        RULE:

            After sending this method any received method except
            Channel.Close-OK MUST be discarded.

        RULE:

            The peer sending this method MAY use a counter or timeout
            to detect failure of the other peer to respond correctly
            with Channel.Close-OK..

        PARAMETERS:
            reply_code: short

                The reply code. The AMQ reply codes are defined in AMQ
                RFC 011.

            reply_text: shortstr

                The localised reply text.  This text can be logged as an
                aid to resolving issues.

            class_id: short

                failing method class

                When the close is provoked by a method exception, this
                is the class of the method.

            method_id: short

                failing method ID

                When the close is provoked by a method exception, this
                is the ID of the method.

        """
        try:
            if not self.is_open or self.connection is None:
                return

            args = AMQPWriter()
            args.write_short(reply_code)
            args.write_shortstr(reply_text)
            args.write_short(method_sig[0])  # class_id
            args.write_short(method_sig[1])  # method_id
            self._send_method((20, 40), args)
            return self.wait(allowed_methods=[
                (20, 40),  # Channel.close
                (20, 41),  # Channel.close_ok
            ])
        except (socket.timeout, socket.error) as e:
            # no point in waiting anymore
            if isinstance(e, socket.timeout):
                try:
                    self.connection.sock.settimeout(0.1)
                except:
                    pass
            # lack of communication should not prevent tidy-up
            self._do_close()
        finally:
            self.connection = None

    def _close(self, args):
        """Request a channel close

        This method indicates that the sender wants to close the
        channel. This may be due to internal conditions (e.g. a forced
        shut-down) or due to an error handling a specific method, i.e.
        an exception.  When a close is due to an exception, the sender
        provides the class and method id of the method which caused
        the exception.

        RULE:

            After sending this method any received method except
            Channel.Close-OK MUST be discarded.

        RULE:

            The peer sending this method MAY use a counter or timeout
            to detect failure of the other peer to respond correctly
            with Channel.Close-OK..

        PARAMETERS:
            reply_code: short

                The reply code. The AMQ reply codes are defined in AMQ
                RFC 011.

            reply_text: shortstr

                The localised reply text.  This text can be logged as an
                aid to resolving issues.

            class_id: short

                failing method class

                When the close is provoked by a method exception, this
                is the class of the method.

            method_id: short

                failing method ID

                When the close is provoked by a method exception, this
                is the ID of the method.

        """

        reply_code = args.read_short()
        reply_text = args.read_shortstr()
        class_id = args.read_short()
        method_id = args.read_short()

        self._send_method((20, 41))
        self._do_revive()

        raise error_for_code(
            reply_code, reply_text, (class_id, method_id), ChannelError,
        )

    def _close_ok(self, args):
        """Confirm a channel close

        This method confirms a Channel.Close method and tells the
        recipient that it is safe to release resources for the channel
        and close the socket.

        RULE:

            A peer that detects a socket closure without having
            received a Channel.Close-Ok handshake method SHOULD log
            the error.

        """
        self._do_close()

    def flow(self, active):
        """Enable/disable flow from peer

        This method asks the peer to pause or restart the flow of
        content data. This is a simple flow-control mechanism that a
        peer can use to avoid oveflowing its queues or otherwise
        finding itself receiving more messages than it can process.
        Note that this method is not intended for window control.  The
        peer that receives a request to stop sending content should
        finish sending the current content, if any, and then wait
        until it receives a Flow restart method.

        RULE:

            When a new channel is opened, it is active.  Some
            applications assume that channels are inactive until
            started.  To emulate this behaviour a client MAY open the
            channel, then pause it.

        RULE:

            When sending content data in multiple frames, a peer
            SHOULD monitor the channel for incoming methods and
            respond to a Channel.Flow as rapidly as possible.

        RULE:

            A peer MAY use the Channel.Flow method to throttle
            incoming content data for internal reasons, for example,
            when exchangeing data over a slower connection.

        RULE:

            The peer that requests a Channel.Flow method MAY
            disconnect and/or ban a peer that does not respect the
            request.

        PARAMETERS:
            active: boolean

                start/stop content frames

                If True, the peer starts sending content frames.  If
                False, the peer stops sending content frames.

        """
        args = AMQPWriter()
        args.write_bit(active)
        self._send_method((20, 20), args)
        return self.wait(allowed_methods=[
            (20, 21),  # Channel.flow_ok
        ])

    def _flow(self, args):
        """Enable/disable flow from peer

        This method asks the peer to pause or restart the flow of
        content data. This is a simple flow-control mechanism that a
        peer can use to avoid oveflowing its queues or otherwise
        finding itself receiving more messages than it can process.
        Note that this method is not intended for window control.  The
        peer that receives a request to stop sending content should
        finish sending the current content, if any, and then wait
        until it receives a Flow restart method.

        RULE:

            When a new channel is opened, it is active.  Some
            applications assume that channels are inactive until
            started.  To emulate this behaviour a client MAY open the
            channel, then pause it.

        RULE:

            When sending content data in multiple frames, a peer
            SHOULD monitor the channel for incoming methods and
            respond to a Channel.Flow as rapidly as possible.

        RULE:

            A peer MAY use the Channel.Flow method to throttle
            incoming content data for internal reasons, for example,
            when exchangeing data over a slower connection.

        RULE:

            The peer that requests a Channel.Flow method MAY
            disconnect and/or ban a peer that does not respect the
            request.

        PARAMETERS:
            active: boolean

                start/stop content frames

                If True, the peer starts sending content frames.  If
                False, the peer stops sending content frames.

        """
        self.active = args.read_bit()
        self._x_flow_ok(self.active)

    def _x_flow_ok(self, active):
        """Confirm a flow method

        Confirms to the peer that a flow command was received and
        processed.

        PARAMETERS:
            active: boolean

                current flow setting

                Confirms the setting of the processed flow method:
                True means the peer will start sending or continue
                to send content frames; False means it will not.

        """
        args = AMQPWriter()
        args.write_bit(active)
        self._send_method((20, 21), args)

    def _flow_ok(self, args):
        """Confirm a flow method

        Confirms to the peer that a flow command was received and
        processed.

        PARAMETERS:
            active: boolean

                current flow setting

                Confirms the setting of the processed flow method:
                True means the peer will start sending or continue
                to send content frames; False means it will not.

        """
        return args.read_bit()

    def _x_open(self):
        """Open a channel for use

        This method opens a virtual connection (a channel).

        RULE:

            This method MUST NOT be called when the channel is already
            open.

        PARAMETERS:
            out_of_band: shortstr (DEPRECATED)

                out-of-band settings

                Configures out-of-band transfers on this channel.  The
                syntax and meaning of this field will be formally
                defined at a later date.

        """
        if self.is_open:
            return

        args = AMQPWriter()
        args.write_shortstr('')  # out_of_band: deprecated
        self._send_method((20, 10), args)
        return self.wait(allowed_methods=[
            (20, 11),  # Channel.open_ok
        ])

    def _open_ok(self, args):
        """Signal that the channel is ready

        This method signals to the client that the channel is ready
        for use.

        """
        self.is_open = True
        AMQP_LOGGER.debug('Channel open')

    #############
    #
    #  Exchange
    #
    #
    # work with exchanges
    #
    # Exchanges match and distribute messages across queues.
    # Exchanges can be configured in the server or created at runtime.
    #
    # GRAMMAR::
    #
    #     exchange            = C:DECLARE  S:DECLARE-OK
    #                         / C:DELETE   S:DELETE-OK
    #
    # RULE:
    #
    #     The server MUST implement the direct and fanout exchange
    #     types, and predeclare the corresponding exchanges named
    #     amq.direct and amq.fanout in each virtual host. The server
    #     MUST also predeclare a direct exchange to act as the default
    #     exchange for content Publish methods and for default queue
    #     bindings.
    #
    # RULE:
    #
    #     The server SHOULD implement the topic exchange type, and
    #     predeclare the corresponding exchange named amq.topic in
    #     each virtual host.
    #
    # RULE:
    #
    #     The server MAY implement the system exchange type, and
    #     predeclare the corresponding exchanges named amq.system in
    #     each virtual host. If the client attempts to bind a queue to
    #     the system exchange, the server MUST raise a connection
    #     exception with reply code 507 (not allowed).
    #

    def exchange_declare(self, exchange, type, passive=False, durable=False,
                         auto_delete=True, nowait=False, arguments=None):
        """Declare exchange, create if needed

        This method creates an exchange if it does not already exist,
        and if the exchange exists, verifies that it is of the correct
        and expected class.

        RULE:

            The server SHOULD support a minimum of 16 exchanges per
            virtual host and ideally, impose no limit except as
            defined by available resources.

        PARAMETERS:
            exchange: shortstr

                RULE:

                    Exchange names starting with "amq." are reserved
                    for predeclared and standardised exchanges.  If
                    the client attempts to create an exchange starting
                    with "amq.", the server MUST raise a channel
                    exception with reply code 403 (access refused).

            type: shortstr

                exchange type

                Each exchange belongs to one of a set of exchange
                types implemented by the server.  The exchange types
                define the functionality of the exchange - i.e. how
                messages are routed through it.  It is not valid or
                meaningful to attempt to change the type of an
                existing exchange.

                RULE:

                    If the exchange already exists with a different
                    type, the server MUST raise a connection exception
                    with a reply code 507 (not allowed).

                RULE:

                    If the server does not support the requested
                    exchange type it MUST raise a connection exception
                    with a reply code 503 (command invalid).

            passive: boolean

                do not create exchange

                If set, the server will not create the exchange.  The
                client can use this to check whether an exchange
                exists without modifying the server state.

                RULE:

                    If set, and the exchange does not already exist,
                    the server MUST raise a channel exception with
                    reply code 404 (not found).

            durable: boolean

                request a durable exchange

                If set when creating a new exchange, the exchange will
                be marked as durable.  Durable exchanges remain active
                when a server restarts. Non-durable exchanges
                (transient exchanges) are purged if/when a server
                restarts.

                RULE:

                    The server MUST support both durable and transient
                    exchanges.

                RULE:

                    The server MUST ignore the durable field if the
                    exchange already exists.

            auto_delete: boolean

                auto-delete when unused

                If set, the exchange is deleted when all queues have
                finished using it.

                RULE:

                    The server SHOULD allow for a reasonable delay
                    between the point when it determines that an
                    exchange is not being used (or no longer used),
                    and the point when it deletes the exchange.  At
                    the least it must allow a client to create an
                    exchange and then bind a queue to it, with a small
                    but non-zero delay between these two actions.

                RULE:

                    The server MUST ignore the auto-delete field if
                    the exchange already exists.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

            arguments: table

                arguments for declaration

                A set of arguments for the declaration. The syntax and
                semantics of these arguments depends on the server
                implementation.  This field is ignored if passive is
                True.

        """
        arguments = {} if arguments is None else arguments
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(exchange)
        args.write_shortstr(type)
        args.write_bit(passive)
        args.write_bit(durable)
        args.write_bit(auto_delete)
        args.write_bit(False)  # internal: deprecated
        args.write_bit(nowait)
        args.write_table(arguments)
        self._send_method((40, 10), args)

        if auto_delete:
            warn(VDeprecationWarning(EXCHANGE_AUTODELETE_DEPRECATED))

        if not nowait:
            return self.wait(allowed_methods=[
                (40, 11),  # Channel.exchange_declare_ok
            ])

    def _exchange_declare_ok(self, args):
        """Confirms an exchange declaration

        This method confirms a Declare method and confirms the name of
        the exchange, essential for automatically-named exchanges.

        """
        pass

    def exchange_delete(self, exchange, if_unused=False, nowait=False):
        """Delete an exchange

        This method deletes an exchange.  When an exchange is deleted
        all queue bindings on the exchange are cancelled.

        PARAMETERS:
            exchange: shortstr

                RULE:

                    The exchange MUST exist. Attempting to delete a
                    non-existing exchange causes a channel exception.

            if_unused: boolean

                delete only if unused

                If set, the server will only delete the exchange if it
                has no queue bindings. If the exchange has queue
                bindings the server does not delete it but raises a
                channel exception instead.

                RULE:

                    If set, the server SHOULD delete the exchange but
                    only if it has no queue bindings.

                RULE:

                    If set, the server SHOULD raise a channel
                    exception if the exchange is in use.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

        """
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(exchange)
        args.write_bit(if_unused)
        args.write_bit(nowait)
        self._send_method((40, 20), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (40, 21),  # Channel.exchange_delete_ok
            ])

    def _exchange_delete_ok(self, args):
        """Confirm deletion of an exchange

        This method confirms the deletion of an exchange.

        """
        pass

    def exchange_bind(self, destination, source='', routing_key='',
                      nowait=False, arguments=None):
        """This method binds an exchange to an exchange.

        RULE:

            A server MUST allow and ignore duplicate bindings - that
            is, two or more bind methods for a specific exchanges,
            with identical arguments - without treating these as an
            error.

        RULE:

            A server MUST allow cycles of exchange bindings to be
            created including allowing an exchange to be bound to
            itself.

        RULE:

            A server MUST not deliver the same message more than once
            to a destination exchange, even if the topology of
            exchanges and bindings results in multiple (even infinite)
            routes to that exchange.

        PARAMETERS:
            reserved-1: short

            destination: shortstr

                Specifies the name of the destination exchange to
                bind.

                RULE:

                    A client MUST NOT be allowed to bind a non-
                    existent destination exchange.

                RULE:

                    The server MUST accept a blank exchange name to
                    mean the default exchange.

            source: shortstr

                Specifies the name of the source exchange to bind.

                RULE:

                    A client MUST NOT be allowed to bind a non-
                    existent source exchange.

                RULE:

                    The server MUST accept a blank exchange name to
                    mean the default exchange.

            routing-key: shortstr

                Specifies the routing key for the binding. The routing
                key is used for routing messages depending on the
                exchange configuration. Not all exchanges use a
                routing key - refer to the specific exchange
                documentation.

            no-wait: bit

            arguments: table

                A set of arguments for the binding. The syntax and
                semantics of these arguments depends on the exchange
                class.

        """
        arguments = {} if arguments is None else arguments
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(destination)
        args.write_shortstr(source)
        args.write_shortstr(routing_key)
        args.write_bit(nowait)
        args.write_table(arguments)
        self._send_method((40, 30), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (40, 31),  # Channel.exchange_bind_ok
            ])

    def exchange_unbind(self, destination, source='', routing_key='',
                        nowait=False, arguments=None):
        """This method unbinds an exchange from an exchange.

        RULE:

            If a unbind fails, the server MUST raise a connection
            exception.

        PARAMETERS:
            reserved-1: short

            destination: shortstr

                Specifies the name of the destination exchange to
                unbind.

                RULE:

                    The client MUST NOT attempt to unbind an exchange
                    that does not exist from an exchange.

                RULE:

                    The server MUST accept a blank exchange name to
                    mean the default exchange.

            source: shortstr

                Specifies the name of the source exchange to unbind.

                RULE:

                    The client MUST NOT attempt to unbind an exchange
                    from an exchange that does not exist.

                RULE:

                    The server MUST accept a blank exchange name to
                    mean the default exchange.

            routing-key: shortstr

                Specifies the routing key of the binding to unbind.

            no-wait: bit

            arguments: table

                Specifies the arguments of the binding to unbind.

        """
        arguments = {} if arguments is None else arguments
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(destination)
        args.write_shortstr(source)
        args.write_shortstr(routing_key)
        args.write_bit(nowait)
        args.write_table(arguments)
        self._send_method((40, 40), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (40, 51),  # Channel.exchange_unbind_ok
            ])

    def _exchange_bind_ok(self, args):
        """Confirm bind successful

        This method confirms that the bind was successful.

        """
        pass

    def _exchange_unbind_ok(self, args):
        """Confirm unbind successful

        This method confirms that the unbind was successful.

        """
        pass

    #############
    #
    #  Queue
    #
    #
    # work with queues
    #
    # Queues store and forward messages.  Queues can be configured in
    # the server or created at runtime.  Queues must be attached to at
    # least one exchange in order to receive messages from publishers.
    #
    # GRAMMAR::
    #
    #     queue               = C:DECLARE  S:DECLARE-OK
    #                         / C:BIND     S:BIND-OK
    #                         / C:PURGE    S:PURGE-OK
    #                         / C:DELETE   S:DELETE-OK
    #
    # RULE:
    #
    #     A server MUST allow any content class to be sent to any
    #     queue, in any mix, and queue and delivery these content
    #     classes independently. Note that all methods that fetch
    #     content off queues are specific to a given content class.
    #

    def queue_bind(self, queue, exchange='', routing_key='',
                   nowait=False, arguments=None):
        """Bind queue to an exchange

        This method binds a queue to an exchange.  Until a queue is
        bound it will not receive any messages.  In a classic
        messaging model, store-and-forward queues are bound to a dest
        exchange and subscription queues are bound to a dest_wild
        exchange.

        RULE:

            A server MUST allow ignore duplicate bindings - that is,
            two or more bind methods for a specific queue, with
            identical arguments - without treating these as an error.

        RULE:

            If a bind fails, the server MUST raise a connection
            exception.

        RULE:

            The server MUST NOT allow a durable queue to bind to a
            transient exchange. If the client attempts this the server
            MUST raise a channel exception.

        RULE:

            Bindings for durable queues are automatically durable and
            the server SHOULD restore such bindings after a server
            restart.

        RULE:

            The server SHOULD support at least 4 bindings per queue,
            and ideally, impose no limit except as defined by
            available resources.

        PARAMETERS:
            queue: shortstr

                Specifies the name of the queue to bind.  If the queue
                name is empty, refers to the current queue for the
                channel, which is the last declared queue.

                RULE:

                    If the client did not previously declare a queue,
                    and the queue name in this method is empty, the
                    server MUST raise a connection exception with
                    reply code 530 (not allowed).

                RULE:

                    If the queue does not exist the server MUST raise
                    a channel exception with reply code 404 (not
                    found).

            exchange: shortstr

                The name of the exchange to bind to.

                RULE:

                    If the exchange does not exist the server MUST
                    raise a channel exception with reply code 404 (not
                    found).

            routing_key: shortstr

                message routing key

                Specifies the routing key for the binding.  The
                routing key is used for routing messages depending on
                the exchange configuration. Not all exchanges use a
                routing key - refer to the specific exchange
                documentation.  If the routing key is empty and the
                queue name is empty, the routing key will be the
                current queue for the channel, which is the last
                declared queue.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

            arguments: table

                arguments for binding

                A set of arguments for the binding.  The syntax and
                semantics of these arguments depends on the exchange
                class.
        """
        arguments = {} if arguments is None else arguments
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_shortstr(exchange)
        args.write_shortstr(routing_key)
        args.write_bit(nowait)
        args.write_table(arguments)
        self._send_method((50, 20), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (50, 21),  # Channel.queue_bind_ok
            ])

    def _queue_bind_ok(self, args):
        """Confirm bind successful

        This method confirms that the bind was successful.

        """
        pass

    def queue_unbind(self, queue, exchange, routing_key='',
                     nowait=False, arguments=None):
        """Unbind a queue from an exchange

        This method unbinds a queue from an exchange.

        RULE:

            If a unbind fails, the server MUST raise a connection exception.

        PARAMETERS:
            queue: shortstr

                Specifies the name of the queue to unbind.

                RULE:

                    The client MUST either specify a queue name or have
                    previously declared a queue on the same channel

                RULE:

                    The client MUST NOT attempt to unbind a queue that
                    does not exist.

            exchange: shortstr

                The name of the exchange to unbind from.

                RULE:

                    The client MUST NOT attempt to unbind a queue from an
                    exchange that does not exist.

                RULE:

                    The server MUST accept a blank exchange name to mean
                    the default exchange.

            routing_key: shortstr

                routing key of binding

                Specifies the routing key of the binding to unbind.

            arguments: table

                arguments of binding

                Specifies the arguments of the binding to unbind.

        """
        arguments = {} if arguments is None else arguments
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_shortstr(exchange)
        args.write_shortstr(routing_key)
        args.write_table(arguments)
        self._send_method((50, 50), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (50, 51),  # Channel.queue_unbind_ok
            ])

    def _queue_unbind_ok(self, args):
        """Confirm unbind successful

        This method confirms that the unbind was successful.

        """
        pass

    def queue_declare(self, queue='', passive=False, durable=False,
                      exclusive=False, auto_delete=True, nowait=False,
                      arguments=None):
        """Declare queue, create if needed

        This method creates or checks a queue.  When creating a new
        queue the client can specify various properties that control
        the durability of the queue and its contents, and the level of
        sharing for the queue.

        RULE:

            The server MUST create a default binding for a newly-
            created queue to the default exchange, which is an
            exchange of type 'direct'.

        RULE:

            The server SHOULD support a minimum of 256 queues per
            virtual host and ideally, impose no limit except as
            defined by available resources.

        PARAMETERS:
            queue: shortstr

                RULE:

                    The queue name MAY be empty, in which case the
                    server MUST create a new queue with a unique
                    generated name and return this to the client in
                    the Declare-Ok method.

                RULE:

                    Queue names starting with "amq." are reserved for
                    predeclared and standardised server queues.  If
                    the queue name starts with "amq." and the passive
                    option is False, the server MUST raise a connection
                    exception with reply code 403 (access refused).

            passive: boolean

                do not create queue

                If set, the server will not create the queue.  The
                client can use this to check whether a queue exists
                without modifying the server state.

                RULE:

                    If set, and the queue does not already exist, the
                    server MUST respond with a reply code 404 (not
                    found) and raise a channel exception.

            durable: boolean

                request a durable queue

                If set when creating a new queue, the queue will be
                marked as durable.  Durable queues remain active when
                a server restarts. Non-durable queues (transient
                queues) are purged if/when a server restarts.  Note
                that durable queues do not necessarily hold persistent
                messages, although it does not make sense to send
                persistent messages to a transient queue.

                RULE:

                    The server MUST recreate the durable queue after a
                    restart.

                RULE:

                    The server MUST support both durable and transient
                    queues.

                RULE:

                    The server MUST ignore the durable field if the
                    queue already exists.

            exclusive: boolean

                request an exclusive queue

                Exclusive queues may only be consumed from by the
                current connection. Setting the 'exclusive' flag
                always implies 'auto-delete'.

                RULE:

                    The server MUST support both exclusive (private)
                    and non-exclusive (shared) queues.

                RULE:

                    The server MUST raise a channel exception if
                    'exclusive' is specified and the queue already
                    exists and is owned by a different connection.

            auto_delete: boolean

                auto-delete queue when unused

                If set, the queue is deleted when all consumers have
                finished using it. Last consumer can be cancelled
                either explicitly or because its channel is closed. If
                there was no consumer ever on the queue, it won't be
                deleted.

                RULE:

                    The server SHOULD allow for a reasonable delay
                    between the point when it determines that a queue
                    is not being used (or no longer used), and the
                    point when it deletes the queue.  At the least it
                    must allow a client to create a queue and then
                    create a consumer to read from it, with a small
                    but non-zero delay between these two actions.  The
                    server should equally allow for clients that may
                    be disconnected prematurely, and wish to re-
                    consume from the same queue without losing
                    messages.  We would recommend a configurable
                    timeout, with a suitable default value being one
                    minute.

                RULE:

                    The server MUST ignore the auto-delete field if
                    the queue already exists.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

            arguments: table

                arguments for declaration

                A set of arguments for the declaration. The syntax and
                semantics of these arguments depends on the server
                implementation.  This field is ignored if passive is
                True.

        Returns a tuple containing 3 items:
            the name of the queue (essential for automatically-named queues)
            message count
            consumer count

        """
        arguments = {} if arguments is None else arguments
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_bit(passive)
        args.write_bit(durable)
        args.write_bit(exclusive)
        args.write_bit(auto_delete)
        args.write_bit(nowait)
        args.write_table(arguments)
        self._send_method((50, 10), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (50, 11),  # Channel.queue_declare_ok
            ])

    def _queue_declare_ok(self, args):
        """Confirms a queue definition

        This method confirms a Declare method and confirms the name of
        the queue, essential for automatically-named queues.

        PARAMETERS:
            queue: shortstr

                Reports the name of the queue. If the server generated
                a queue name, this field contains that name.

            message_count: long

                number of messages in queue

                Reports the number of messages in the queue, which
                will be zero for newly-created queues.

            consumer_count: long

                number of consumers

                Reports the number of active consumers for the queue.
                Note that consumers can suspend activity
                (Channel.Flow) in which case they do not appear in
                this count.

        """
        return queue_declare_ok_t(
            args.read_shortstr(),
            args.read_long(),
            args.read_long(),
        )

    def queue_delete(self, queue='',
                     if_unused=False, if_empty=False, nowait=False):
        """Delete a queue

        This method deletes a queue.  When a queue is deleted any
        pending messages are sent to a dead-letter queue if this is
        defined in the server configuration, and all consumers on the
        queue are cancelled.

        RULE:

            The server SHOULD use a dead-letter queue to hold messages
            that were pending on a deleted queue, and MAY provide
            facilities for a system administrator to move these
            messages back to an active queue.

        PARAMETERS:
            queue: shortstr

                Specifies the name of the queue to delete. If the
                queue name is empty, refers to the current queue for
                the channel, which is the last declared queue.

                RULE:

                    If the client did not previously declare a queue,
                    and the queue name in this method is empty, the
                    server MUST raise a connection exception with
                    reply code 530 (not allowed).

                RULE:

                    The queue must exist. Attempting to delete a non-
                    existing queue causes a channel exception.

            if_unused: boolean

                delete only if unused

                If set, the server will only delete the queue if it
                has no consumers. If the queue has consumers the
                server does does not delete it but raises a channel
                exception instead.

                RULE:

                    The server MUST respect the if-unused flag when
                    deleting a queue.

            if_empty: boolean

                delete only if empty

                If set, the server will only delete the queue if it
                has no messages. If the queue is not empty the server
                raises a channel exception.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

        """
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_bit(if_unused)
        args.write_bit(if_empty)
        args.write_bit(nowait)
        self._send_method((50, 40), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (50, 41),  # Channel.queue_delete_ok
            ])

    def _queue_delete_ok(self, args):
        """Confirm deletion of a queue

        This method confirms the deletion of a queue.

        PARAMETERS:
            message_count: long

                number of messages purged

                Reports the number of messages purged.

        """
        return args.read_long()

    def queue_purge(self, queue='', nowait=False):
        """Purge a queue

        This method removes all messages from a queue.  It does not
        cancel consumers.  Purged messages are deleted without any
        formal "undo" mechanism.

        RULE:

            A call to purge MUST result in an empty queue.

        RULE:

            On transacted channels the server MUST not purge messages
            that have already been sent to a client but not yet
            acknowledged.

        RULE:

            The server MAY implement a purge queue or log that allows
            system administrators to recover accidentally-purged
            messages.  The server SHOULD NOT keep purged messages in
            the same storage spaces as the live messages since the
            volumes of purged messages may get very large.

        PARAMETERS:
            queue: shortstr

                Specifies the name of the queue to purge.  If the
                queue name is empty, refers to the current queue for
                the channel, which is the last declared queue.

                RULE:

                    If the client did not previously declare a queue,
                    and the queue name in this method is empty, the
                    server MUST raise a connection exception with
                    reply code 530 (not allowed).

                RULE:

                    The queue must exist. Attempting to purge a non-
                    existing queue causes a channel exception.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

        if nowait is False, returns a message_count

        """
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_bit(nowait)
        self._send_method((50, 30), args)

        if not nowait:
            return self.wait(allowed_methods=[
                (50, 31),  # Channel.queue_purge_ok
            ])

    def _queue_purge_ok(self, args):
        """Confirms a queue purge

        This method confirms the purge of a queue.

        PARAMETERS:
            message_count: long

                number of messages purged

                Reports the number of messages purged.

        """
        return args.read_long()

    #############
    #
    #  Basic
    #
    #
    # work with basic content
    #
    # The Basic class provides methods that support an industry-
    # standard messaging model.
    #
    # GRAMMAR::
    #
    #     basic               = C:QOS S:QOS-OK
    #                         / C:CONSUME S:CONSUME-OK
    #                         / C:CANCEL S:CANCEL-OK
    #                         / C:PUBLISH content
    #                         / S:RETURN content
    #                         / S:DELIVER content
    #                         / C:GET ( S:GET-OK content / S:GET-EMPTY )
    #                         / C:ACK
    #                         / C:REJECT
    #
    # RULE:
    #
    #     The server SHOULD respect the persistent property of basic
    #     messages and SHOULD make a best-effort to hold persistent
    #     basic messages on a reliable storage mechanism.
    #
    # RULE:
    #
    #     The server MUST NOT discard a persistent basic message in
    #     case of a queue overflow. The server MAY use the
    #     Channel.Flow method to slow or stop a basic message
    #     publisher when necessary.
    #
    # RULE:
    #
    #     The server MAY overflow non-persistent basic messages to
    #     persistent storage and MAY discard or dead-letter non-
    #     persistent basic messages on a priority basis if the queue
    #     size exceeds some configured limit.
    #
    # RULE:
    #
    #     The server MUST implement at least 2 priority levels for
    #     basic messages, where priorities 0-4 and 5-9 are treated as
    #     two distinct levels. The server MAY implement up to 10
    #     priority levels.
    #
    # RULE:
    #
    #     The server MUST deliver messages of the same priority in
    #     order irrespective of their individual persistence.
    #
    # RULE:
    #
    #     The server MUST support both automatic and explicit
    #     acknowledgements on Basic content.
    #

    def basic_ack(self, delivery_tag, multiple=False):
        """Acknowledge one or more messages

        This method acknowledges one or more messages delivered via
        the Deliver or Get-Ok methods.  The client can ask to confirm
        a single message or a set of messages up to and including a
        specific message.

        PARAMETERS:
            delivery_tag: longlong

                server-assigned delivery tag

                The server-assigned and channel-specific delivery tag

                RULE:

                    The delivery tag is valid only within the channel
                    from which the message was received.  I.e. a client
                    MUST NOT receive a message on one channel and then
                    acknowledge it on another.

                RULE:

                    The server MUST NOT use a zero value for delivery
                    tags.  Zero is reserved for client use, meaning "all
                    messages so far received".

            multiple: boolean

                acknowledge multiple messages

                If set to True, the delivery tag is treated as "up to
                and including", so that the client can acknowledge
                multiple messages with a single method.  If set to
                False, the delivery tag refers to a single message.
                If the multiple field is True, and the delivery tag
                is zero, tells the server to acknowledge all
                outstanding mesages.

                RULE:

                    The server MUST validate that a non-zero delivery-
                    tag refers to an delivered message, and raise a
                    channel exception if this is not the case.

        """
        args = AMQPWriter()
        args.write_longlong(delivery_tag)
        args.write_bit(multiple)
        self._send_method((60, 80), args)

    def basic_cancel(self, consumer_tag, nowait=False):
        """End a queue consumer

        This method cancels a consumer. This does not affect already
        delivered messages, but it does mean the server will not send
        any more messages for that consumer.  The client may receive
        an abitrary number of messages in between sending the cancel
        method and receiving the cancel-ok reply.

        RULE:

            If the queue no longer exists when the client sends a
            cancel command, or the consumer has been cancelled for
            other reasons, this command has no effect.

        PARAMETERS:
            consumer_tag: shortstr

                consumer tag

                Identifier for the consumer, valid within the current
                connection.

                RULE:

                    The consumer tag is valid only within the channel
                    from which the consumer was created. I.e. a client
                    MUST NOT create a consumer in one channel and then
                    use it in another.

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

        """
        if self.connection is not None:
            self.no_ack_consumers.discard(consumer_tag)
            args = AMQPWriter()
            args.write_shortstr(consumer_tag)
            args.write_bit(nowait)
            self._send_method((60, 30), args)
            return self.wait(allowed_methods=[
                (60, 31),  # Channel.basic_cancel_ok
            ])

    def _basic_cancel_notify(self, args):
        """Consumer cancelled by server.

        Most likely the queue was deleted.

        """
        consumer_tag = args.read_shortstr()
        callback = self._on_cancel(consumer_tag)
        if callback:
            callback(consumer_tag)
        else:
            raise ConsumerCancelled(consumer_tag, (60, 30))

    def _basic_cancel_ok(self, args):
        """Confirm a cancelled consumer

        This method confirms that the cancellation was completed.

        PARAMETERS:
            consumer_tag: shortstr

                consumer tag

                Identifier for the consumer, valid within the current
                connection.

                RULE:

                    The consumer tag is valid only within the channel
                    from which the consumer was created. I.e. a client
                    MUST NOT create a consumer in one channel and then
                    use it in another.

        """
        consumer_tag = args.read_shortstr()
        self._on_cancel(consumer_tag)

    def _on_cancel(self, consumer_tag):
        self.callbacks.pop(consumer_tag, None)
        return self.cancel_callbacks.pop(consumer_tag, None)

    def basic_consume(self, queue='', consumer_tag='', no_local=False,
                      no_ack=False, exclusive=False, nowait=False,
                      callback=None, arguments=None, on_cancel=None):
        """Start a queue consumer

        This method asks the server to start a "consumer", which is a
        transient request for messages from a specific queue.
        Consumers last as long as the channel they were created on, or
        until the client cancels them.

        RULE:

            The server SHOULD support at least 16 consumers per queue,
            unless the queue was declared as private, and ideally,
            impose no limit except as defined by available resources.

        PARAMETERS:
            queue: shortstr

                Specifies the name of the queue to consume from.  If
                the queue name is null, refers to the current queue
                for the channel, which is the last declared queue.

                RULE:

                    If the client did not previously declare a queue,
                    and the queue name in this method is empty, the
                    server MUST raise a connection exception with
                    reply code 530 (not allowed).

            consumer_tag: shortstr

                Specifies the identifier for the consumer. The
                consumer tag is local to a connection, so two clients
                can use the same consumer tags. If this field is empty
                the server will generate a unique tag.

                RULE:

                    The tag MUST NOT refer to an existing consumer. If
                    the client attempts to create two consumers with
                    the same non-empty tag the server MUST raise a
                    connection exception with reply code 530 (not
                    allowed).

            no_local: boolean

                do not deliver own messages

                If the no-local field is set the server will not send
                messages to the client that published them.

            no_ack: boolean

                no acknowledgement needed

                If this field is set the server does not expect
                acknowledgments for messages.  That is, when a message
                is delivered to the client the server automatically and
                silently acknowledges it on behalf of the client.  This
                functionality increases performance but at the cost of
                reliability.  Messages can get lost if a client dies
                before it can deliver them to the application.

            exclusive: boolean

                request exclusive access

                Request exclusive consumer access, meaning only this
                consumer can access the queue.

                RULE:

                    If the server cannot grant exclusive access to the
                    queue when asked, - because there are other
                    consumers active - it MUST raise a channel
                    exception with return code 403 (access refused).

            nowait: boolean

                do not send a reply method

                If set, the server will not respond to the method. The
                client should not wait for a reply method.  If the
                server could not complete the method it will raise a
                channel or connection exception.

            callback: Python callable

                function/method called with each delivered message

                For each message delivered by the broker, the
                callable will be called with a Message object
                as the single argument.  If no callable is specified,
                messages are quietly discarded, no_ack should probably
                be set to True in that case.

        """
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_shortstr(consumer_tag)
        args.write_bit(no_local)
        args.write_bit(no_ack)
        args.write_bit(exclusive)
        args.write_bit(nowait)
        args.write_table(arguments or {})
        self._send_method((60, 20), args)

        if not nowait:
            consumer_tag = self.wait(allowed_methods=[
                (60, 21),  # Channel.basic_consume_ok
            ])

        self.callbacks[consumer_tag] = callback

        if on_cancel:
            self.cancel_callbacks[consumer_tag] = on_cancel
        if no_ack:
            self.no_ack_consumers.add(consumer_tag)

        return consumer_tag

    def _basic_consume_ok(self, args):
        """Confirm a new consumer

        The server provides the client with a consumer tag, which is
        used by the client for methods called on the consumer at a
        later stage.

        PARAMETERS:
            consumer_tag: shortstr

                Holds the consumer tag specified by the client or
                provided by the server.

        """
        return args.read_shortstr()

    def _basic_deliver(self, args, msg):
        """Notify the client of a consumer message

        This method delivers a message to the client, via a consumer.
        In the asynchronous message delivery model, the client starts
        a consumer using the Consume method, then the server responds
        with Deliver methods as and when messages arrive for that
        consumer.

        RULE:

            The server SHOULD track the number of times a message has
            been delivered to clients and when a message is
            redelivered a certain number of times - e.g. 5 times -
            without being acknowledged, the server SHOULD consider the
            message to be unprocessable (possibly causing client
            applications to abort), and move the message to a dead
            letter queue.

        PARAMETERS:
            consumer_tag: shortstr

                consumer tag

                Identifier for the consumer, valid within the current
                connection.

                RULE:

                    The consumer tag is valid only within the channel
                    from which the consumer was created. I.e. a client
                    MUST NOT create a consumer in one channel and then
                    use it in another.

            delivery_tag: longlong

                server-assigned delivery tag

                The server-assigned and channel-specific delivery tag

                RULE:

                    The delivery tag is valid only within the channel
                    from which the message was received.  I.e. a client
                    MUST NOT receive a message on one channel and then
                    acknowledge it on another.

                RULE:

                    The server MUST NOT use a zero value for delivery
                    tags.  Zero is reserved for client use, meaning "all
                    messages so far received".

            redelivered: boolean

                message is being redelivered

                This indicates that the message has been previously
                delivered to this or another client.

            exchange: shortstr

                Specifies the name of the exchange that the message
                was originally published to.

            routing_key: shortstr

                Message routing key

                Specifies the routing key name specified when the
                message was published.

        """
        consumer_tag = args.read_shortstr()
        delivery_tag = args.read_longlong()
        redelivered = args.read_bit()
        exchange = args.read_shortstr()
        routing_key = args.read_shortstr()

        msg.channel = self
        msg.delivery_info = {
            'consumer_tag': consumer_tag,
            'delivery_tag': delivery_tag,
            'redelivered': redelivered,
            'exchange': exchange,
            'routing_key': routing_key,
        }

        try:
            fun = self.callbacks[consumer_tag]
        except KeyError:
            pass
        else:
            fun(msg)

    def basic_get(self, queue='', no_ack=False):
        """Direct access to a queue

        This method provides a direct access to the messages in a
        queue using a synchronous dialogue that is designed for
        specific types of application where synchronous functionality
        is more important than performance.

        PARAMETERS:
            queue: shortstr

                Specifies the name of the queue to consume from.  If
                the queue name is null, refers to the current queue
                for the channel, which is the last declared queue.

                RULE:

                    If the client did not previously declare a queue,
                    and the queue name in this method is empty, the
                    server MUST raise a connection exception with
                    reply code 530 (not allowed).

            no_ack: boolean

                no acknowledgement needed

                If this field is set the server does not expect
                acknowledgments for messages.  That is, when a message
                is delivered to the client the server automatically and
                silently acknowledges it on behalf of the client.  This
                functionality increases performance but at the cost of
                reliability.  Messages can get lost if a client dies
                before it can deliver them to the application.

        Non-blocking, returns a message object, or None.

        """
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(queue)
        args.write_bit(no_ack)
        self._send_method((60, 70), args)
        return self.wait(allowed_methods=[
            (60, 71),  # Channel.basic_get_ok
            (60, 72),  # Channel.basic_get_empty
        ])

    def _basic_get_empty(self, args):
        """Indicate no messages available

        This method tells the client that the queue has no messages
        available for the client.

        PARAMETERS:
            cluster_id: shortstr

                Cluster id

                For use by cluster applications, should not be used by
                client applications.

        """
        cluster_id = args.read_shortstr()  # noqa

    def _basic_get_ok(self, args, msg):
        """Provide client with a message

        This method delivers a message to the client following a get
        method.  A message delivered by 'get-ok' must be acknowledged
        unless the no-ack option was set in the get method.

        PARAMETERS:
            delivery_tag: longlong

                server-assigned delivery tag

                The server-assigned and channel-specific delivery tag

                RULE:

                    The delivery tag is valid only within the channel
                    from which the message was received.  I.e. a client
                    MUST NOT receive a message on one channel and then
                    acknowledge it on another.

                RULE:

                    The server MUST NOT use a zero value for delivery
                    tags.  Zero is reserved for client use, meaning "all
                    messages so far received".

            redelivered: boolean

                message is being redelivered

                This indicates that the message has been previously
                delivered to this or another client.

            exchange: shortstr

                Specifies the name of the exchange that the message
                was originally published to.  If empty, the message
                was published to the default exchange.

            routing_key: shortstr

                Message routing key

                Specifies the routing key name specified when the
                message was published.

            message_count: long

                number of messages pending

                This field reports the number of messages pending on
                the queue, excluding the message being delivered.
                Note that this figure is indicative, not reliable, and
                can change arbitrarily as messages are added to the
                queue and removed by other clients.

        """
        delivery_tag = args.read_longlong()
        redelivered = args.read_bit()
        exchange = args.read_shortstr()
        routing_key = args.read_shortstr()
        message_count = args.read_long()

        msg.channel = self
        msg.delivery_info = {
            'delivery_tag': delivery_tag,
            'redelivered': redelivered,
            'exchange': exchange,
            'routing_key': routing_key,
            'message_count': message_count
        }
        return msg

    def _basic_publish(self, msg, exchange='', routing_key='',
                       mandatory=False, immediate=False):
        """Publish a message

        This method publishes a message to a specific exchange. The
        message will be routed to queues as defined by the exchange
        configuration and distributed to any active consumers when the
        transaction, if any, is committed.

        PARAMETERS:
            exchange: shortstr

                Specifies the name of the exchange to publish to.  The
                exchange name can be empty, meaning the default
                exchange.  If the exchange name is specified, and that
                exchange does not exist, the server will raise a
                channel exception.

                RULE:

                    The server MUST accept a blank exchange name to
                    mean the default exchange.

                RULE:

                    The exchange MAY refuse basic content in which
                    case it MUST raise a channel exception with reply
                    code 540 (not implemented).

            routing_key: shortstr

                Message routing key

                Specifies the routing key for the message.  The
                routing key is used for routing messages depending on
                the exchange configuration.

            mandatory: boolean

                indicate mandatory routing

                This flag tells the server how to react if the message
                cannot be routed to a queue.  If this flag is True, the
                server will return an unroutable message with a Return
                method.  If this flag is False, the server silently
                drops the message.

                RULE:

                    The server SHOULD implement the mandatory flag.

            immediate: boolean

                request immediate delivery

                This flag tells the server how to react if the message
                cannot be routed to a queue consumer immediately.  If
                this flag is set, the server will return an
                undeliverable message with a Return method. If this
                flag is zero, the server will queue the message, but
                with no guarantee that it will ever be consumed.

                RULE:

                    The server SHOULD implement the immediate flag.

        """
        args = AMQPWriter()
        args.write_short(0)
        args.write_shortstr(exchange)
        args.write_shortstr(routing_key)
        args.write_bit(mandatory)
        args.write_bit(immediate)

        self._send_method((60, 40), args, msg)
    basic_publish = _basic_publish

    def basic_publish_confirm(self, *args, **kwargs):
        if not self._confirm_selected:
            self._confirm_selected = True
            self.confirm_select()
        ret = self._basic_publish(*args, **kwargs)
        # Basic.Ack / Basic.Nack
        self.wait([(60, 80), (60, 120)])
        return ret

    def basic_qos(self, prefetch_size, prefetch_count, a_global):
        """Specify quality of service

        This method requests a specific quality of service.  The QoS
        can be specified for the current channel or for all channels
        on the connection.  The particular properties and semantics of
        a qos method always depend on the content class semantics.
        Though the qos method could in principle apply to both peers,
        it is currently meaningful only for the server.

        PARAMETERS:
            prefetch_size: long

                prefetch window in octets

                The client can request that messages be sent in
                advance so that when the client finishes processing a
                message, the following message is already held
                locally, rather than needing to be sent down the
                channel.  Prefetching gives a performance improvement.
                This field specifies the prefetch window size in
                octets.  The server will send a message in advance if
                it is equal to or smaller in size than the available
                prefetch size (and also falls into other prefetch
                limits). May be set to zero, meaning "no specific
                limit", although other prefetch limits may still
                apply. The prefetch-size is ignored if the no-ack
                option is set.

                RULE:

                    The server MUST ignore this setting when the
                    client is not processing any messages - i.e. the
                    prefetch size does not limit the transfer of
                    single messages to a client, only the sending in
                    advance of more messages while the client still
                    has one or more unacknowledged messages.

            prefetch_count: short

                prefetch window in messages

                Specifies a prefetch window in terms of whole
                messages.  This field may be used in combination with
                the prefetch-size field; a message will only be sent
                in advance if both prefetch windows (and those at the
                channel and connection level) allow it. The prefetch-
                count is ignored if the no-ack option is set.

                RULE:

                    The server MAY send less data in advance than
                    allowed by the client's specified prefetch windows
                    but it MUST NOT send more.

            a_global: boolean

                apply to entire connection

                By default the QoS settings apply to the current
                channel only.  If this field is set, they are applied
                to the entire connection.

        """
        args = AMQPWriter()
        args.write_long(prefetch_size)
        args.write_short(prefetch_count)
        args.write_bit(a_global)
        self._send_method((60, 10), args)
        return self.wait(allowed_methods=[
            (60, 11),  # Channel.basic_qos_ok
        ])

    def _basic_qos_ok(self, args):
        """Confirm the requested qos

        This method tells the client that the requested QoS levels
        could be handled by the server.  The requested QoS applies to
        all active consumers until a new QoS is defined.

        """
        pass

    def basic_recover(self, requeue=False):
        """Redeliver unacknowledged messages

        This method asks the broker to redeliver all unacknowledged
        messages on a specified channel. Zero or more messages may be
        redelivered.  This method is only allowed on non-transacted
        channels.

        RULE:

            The server MUST set the redelivered flag on all messages
            that are resent.

        RULE:

            The server MUST raise a channel exception if this is
            called on a transacted channel.

        PARAMETERS:
            requeue: boolean

                requeue the message

                If this field is False, the message will be redelivered
                to the original recipient.  If this field is True, the
                server will attempt to requeue the message,
                potentially then delivering it to an alternative
                subscriber.

        """
        args = AMQPWriter()
        args.write_bit(requeue)
        self._send_method((60, 110), args)

    def basic_recover_async(self, requeue=False):
        args = AMQPWriter()
        args.write_bit(requeue)
        self._send_method((60, 100), args)

    def _basic_recover_ok(self, args):
        """In 0-9-1 the deprecated recover solicits a response."""
        pass

    def basic_reject(self, delivery_tag, requeue):
        """Reject an incoming message

        This method allows a client to reject a message.  It can be
        used to interrupt and cancel large incoming messages, or
        return untreatable messages to their original queue.

        RULE:

            The server SHOULD be capable of accepting and process the
            Reject method while sending message content with a Deliver
            or Get-Ok method.  I.e. the server should read and process
            incoming methods while sending output frames.  To cancel a
            partially-send content, the server sends a content body
            frame of size 1 (i.e. with no data except the frame-end
            octet).

        RULE:

            The server SHOULD interpret this method as meaning that
            the client is unable to process the message at this time.

        RULE:

            A client MUST NOT use this method as a means of selecting
            messages to process.  A rejected message MAY be discarded
            or dead-lettered, not necessarily passed to another
            client.

        PARAMETERS:
            delivery_tag: longlong

                server-assigned delivery tag

                The server-assigned and channel-specific delivery tag

                RULE:

                    The delivery tag is valid only within the channel
                    from which the message was received.  I.e. a client
                    MUST NOT receive a message on one channel and then
                    acknowledge it on another.

                RULE:

                    The server MUST NOT use a zero value for delivery
                    tags.  Zero is reserved for client use, meaning "all
                    messages so far received".

            requeue: boolean

                requeue the message

                If this field is False, the message will be discarded.
                If this field is True, the server will attempt to
                requeue the message.

                RULE:

                    The server MUST NOT deliver the message to the
                    same client within the context of the current
                    channel.  The recommended strategy is to attempt
                    to deliver the message to an alternative consumer,
                    and if that is not possible, to move the message
                    to a dead-letter queue.  The server MAY use more
                    sophisticated tracking to hold the message on the
                    queue and redeliver it to the same client at a
                    later stage.

        """
        args = AMQPWriter()
        args.write_longlong(delivery_tag)
        args.write_bit(requeue)
        self._send_method((60, 90), args)

    def _basic_return(self, args, msg):
        """Return a failed message

        This method returns an undeliverable message that was
        published with the "immediate" flag set, or an unroutable
        message published with the "mandatory" flag set. The reply
        code and text provide information about the reason that the
        message was undeliverable.

        PARAMETERS:
            reply_code: short

                The reply code. The AMQ reply codes are defined in AMQ
                RFC 011.

            reply_text: shortstr

                The localised reply text.  This text can be logged as an
                aid to resolving issues.

            exchange: shortstr

                Specifies the name of the exchange that the message
                was originally published to.

            routing_key: shortstr

                Message routing key

                Specifies the routing key name specified when the
                message was published.

        """
        self.returned_messages.put(basic_return_t(
            args.read_short(),
            args.read_shortstr(),
            args.read_shortstr(),
            args.read_shortstr(),
            msg,
        ))

    #############
    #
    #  Tx
    #
    #
    # work with standard transactions
    #
    # Standard transactions provide so-called "1.5 phase commit".  We
    # can ensure that work is never lost, but there is a chance of
    # confirmations being lost, so that messages may be resent.
    # Applications that use standard transactions must be able to
    # detect and ignore duplicate messages.
    #
    # GRAMMAR::
    #
    #     tx                  = C:SELECT S:SELECT-OK
    #                         / C:COMMIT S:COMMIT-OK
    #                         / C:ROLLBACK S:ROLLBACK-OK
    #
    # RULE:
    #
    #     An client using standard transactions SHOULD be able to
    #     track all messages received within a reasonable period, and
    #     thus detect and reject duplicates of the same message. It
    #     SHOULD NOT pass these to the application layer.
    #
    #

    def tx_commit(self):
        """Commit the current transaction

        This method commits all messages published and acknowledged in
        the current transaction.  A new transaction starts immediately
        after a commit.

        """
        self._send_method((90, 20))
        return self.wait(allowed_methods=[
            (90, 21),  # Channel.tx_commit_ok
        ])

    def _tx_commit_ok(self, args):
        """Confirm a successful commit

        This method confirms to the client that the commit succeeded.
        Note that if a commit fails, the server raises a channel
        exception.

        """
        pass

    def tx_rollback(self):
        """Abandon the current transaction

        This method abandons all messages published and acknowledged
        in the current transaction.  A new transaction starts
        immediately after a rollback.

        """
        self._send_method((90, 30))
        return self.wait(allowed_methods=[
            (90, 31),  # Channel.tx_rollback_ok
        ])

    def _tx_rollback_ok(self, args):
        """Confirm a successful rollback

        This method confirms to the client that the rollback
        succeeded. Note that if an rollback fails, the server raises a
        channel exception.

        """
        pass

    def tx_select(self):
        """Select standard transaction mode

        This method sets the channel to use standard transactions.
        The client must use this method at least once on a channel
        before using the Commit or Rollback methods.

        """
        self._send_method((90, 10))
        return self.wait(allowed_methods=[
            (90, 11),  # Channel.tx_select_ok
        ])

    def _tx_select_ok(self, args):
        """Confirm transaction mode

        This method confirms to the client that the channel was
        successfully set to use standard transactions.

        """
        pass

    def confirm_select(self, nowait=False):
        """Enables publisher confirms for this channel (an RabbitMQ
        extension).

        Can now be used if the channel is in transactional mode.

        :param nowait:
            If set, the server will not respond to the method.
            The client should not wait for a reply method. If the
            server could not complete the method it will raise a channel
            or connection exception.

        """
        args = AMQPWriter()
        args.write_bit(nowait)

        self._send_method((85, 10), args)
        if not nowait:
            self.wait(allowed_methods=[
                (85, 11),  # Confirm.select_ok
            ])

    def _confirm_select_ok(self, args):
        """With this method the broker confirms to the client that
        the channel is now using publisher confirms."""
        pass

    def _basic_ack_recv(self, args):
        delivery_tag = args.read_longlong()
        multiple = args.read_bit()
        self._apply_callbacks('basic_ack', delivery_tag, multiple)

    def _apply_callbacks(self, event, *args):
        return [callback(*args) for callback in self.events[event]]

    def _basic_nack(self, args):
        delivery_tag = args.read_longlong()
        multiple = args.read_bit()
        requeue = args.read_bit()
        if not self._apply_callbacks(
                'basic_nack', delivery_tag, multiple, requeue):
            raise NotConfirmed(delivery_tag, (60, 120), 'basic.nack')

    _METHOD_MAP = {
        (20, 11): _open_ok,
        (20, 20): _flow,
        (20, 21): _flow_ok,
        (20, 40): _close,
        (20, 41): _close_ok,
        (40, 11): _exchange_declare_ok,
        (40, 21): _exchange_delete_ok,
        (40, 31): _exchange_bind_ok,
        (40, 51): _exchange_unbind_ok,
        (50, 11): _queue_declare_ok,
        (50, 21): _queue_bind_ok,
        (50, 31): _queue_purge_ok,
        (50, 41): _queue_delete_ok,
        (50, 51): _queue_unbind_ok,
        (60, 11): _basic_qos_ok,
        (60, 21): _basic_consume_ok,
        (60, 30): _basic_cancel_notify,
        (60, 31): _basic_cancel_ok,
        (60, 50): _basic_return,
        (60, 60): _basic_deliver,
        (60, 71): _basic_get_ok,
        (60, 72): _basic_get_empty,
        (60, 80): _basic_ack_recv,
        (60, 120): _basic_nack,
        (60, 111): _basic_recover_ok,
        (85, 11): _confirm_select_ok,
        (90, 11): _tx_select_ok,
        (90, 21): _tx_commit_ok,
        (90, 31): _tx_rollback_ok,
    }

    _IMMEDIATE_METHODS = [
        (60, 50),  # basic_return
    ]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.Channel">Channel</a></li>
          <li>IoticAgent.third.amqp.abstract_channel.AbstractChannel</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, connection, channel_id=None, auto_encode_decode=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a channel bound to a connection and using the specified
numeric channel_id, and open on the server.</p>
<p>The 'auto_encode_decode' parameter (defaults to True), indicates
whether the library should attempt to encode/decode the body
of Messages to/from a Unicode string. The 'content_encoding' property
of the message is used if set, otherwise encoding default to utf-8. If
decode raises an Exception, the message body is left as plain bytes. If
the input is not unicode, it is also left as-is.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.__init__" class="source">
    <pre><code>def __init__(self, connection, channel_id=None, auto_encode_decode=True):
    """Create a channel bound to a connection and using the specified
    numeric channel_id, and open on the server.
    The 'auto_encode_decode' parameter (defaults to True), indicates
    whether the library should attempt to encode/decode the body
    of Messages to/from a Unicode string. The 'content_encoding' property
    of the message is used if set, otherwise encoding default to utf-8. If
    decode raises an Exception, the message body is left as plain bytes. If
    the input is not unicode, it is also left as-is.
    """
    if channel_id:
        connection._claim_channel_id(channel_id)
    else:
        channel_id = connection._get_free_channel_id()
    AMQP_LOGGER.debug('using channel_id: %d', channel_id)
    super(Channel, self).__init__(connection, channel_id)
    self.is_open = False
    self.active = True  # Flow control
    self.returned_messages = Queue()
    self.callbacks = {}
    self.cancel_callbacks = {}
    self.auto_encode_decode = auto_encode_decode
    self.events = defaultdict(set)
    self.no_ack_consumers = set()
    # set first time basic_publish_confirm is called
    # and publisher confirms are enabled for this channel.
    self._confirm_selected = False
    if self.connection.confirm_publish:
        self.basic_publish = self.basic_publish_confirm
    self._x_open()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_ack">
    <p>def <span class="ident">basic_ack</span>(</p><p>self, delivery_tag, multiple=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Acknowledge one or more messages</p>
<p>This method acknowledges one or more messages delivered via
the Deliver or Get-Ok methods.  The client can ask to confirm
a single message or a set of messages up to and including a
specific message.</p>
<p>PARAMETERS:
    delivery_tag: longlong</p>
<pre><code>    server-assigned delivery tag

    The server-assigned and channel-specific delivery tag

    RULE:

        The delivery tag is valid only within the channel
        from which the message was received.  I.e. a client
        MUST NOT receive a message on one channel and then
        acknowledge it on another.

    RULE:

        The server MUST NOT use a zero value for delivery
        tags.  Zero is reserved for client use, meaning "all
        messages so far received".

multiple: boolean

    acknowledge multiple messages

    If set to True, the delivery tag is treated as "up to
    and including", so that the client can acknowledge
    multiple messages with a single method.  If set to
    False, the delivery tag refers to a single message.
    If the multiple field is True, and the delivery tag
    is zero, tells the server to acknowledge all
    outstanding mesages.

    RULE:

        The server MUST validate that a non-zero delivery-
        tag refers to an delivered message, and raise a
        channel exception if this is not the case.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_ack', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_ack" class="source">
    <pre><code>def basic_ack(self, delivery_tag, multiple=False):
    """Acknowledge one or more messages
    This method acknowledges one or more messages delivered via
    the Deliver or Get-Ok methods.  The client can ask to confirm
    a single message or a set of messages up to and including a
    specific message.
    PARAMETERS:
        delivery_tag: longlong
            server-assigned delivery tag
            The server-assigned and channel-specific delivery tag
            RULE:
                The delivery tag is valid only within the channel
                from which the message was received.  I.e. a client
                MUST NOT receive a message on one channel and then
                acknowledge it on another.
            RULE:
                The server MUST NOT use a zero value for delivery
                tags.  Zero is reserved for client use, meaning "all
                messages so far received".
        multiple: boolean
            acknowledge multiple messages
            If set to True, the delivery tag is treated as "up to
            and including", so that the client can acknowledge
            multiple messages with a single method.  If set to
            False, the delivery tag refers to a single message.
            If the multiple field is True, and the delivery tag
            is zero, tells the server to acknowledge all
            outstanding mesages.
            RULE:
                The server MUST validate that a non-zero delivery-
                tag refers to an delivered message, and raise a
                channel exception if this is not the case.
    """
    args = AMQPWriter()
    args.write_longlong(delivery_tag)
    args.write_bit(multiple)
    self._send_method((60, 80), args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_cancel">
    <p>def <span class="ident">basic_cancel</span>(</p><p>self, consumer_tag, nowait=False)</p>
    </div>
    

    
  
    <div class="desc"><p>End a queue consumer</p>
<p>This method cancels a consumer. This does not affect already
delivered messages, but it does mean the server will not send
any more messages for that consumer.  The client may receive
an abitrary number of messages in between sending the cancel
method and receiving the cancel-ok reply.</p>
<p>RULE:</p>
<pre><code>If the queue no longer exists when the client sends a
cancel command, or the consumer has been cancelled for
other reasons, this command has no effect.
</code></pre>
<p>PARAMETERS:
    consumer_tag: shortstr</p>
<pre><code>    consumer tag

    Identifier for the consumer, valid within the current
    connection.

    RULE:

        The consumer tag is valid only within the channel
        from which the consumer was created. I.e. a client
        MUST NOT create a consumer in one channel and then
        use it in another.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_cancel', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_cancel" class="source">
    <pre><code>def basic_cancel(self, consumer_tag, nowait=False):
    """End a queue consumer
    This method cancels a consumer. This does not affect already
    delivered messages, but it does mean the server will not send
    any more messages for that consumer.  The client may receive
    an abitrary number of messages in between sending the cancel
    method and receiving the cancel-ok reply.
    RULE:
        If the queue no longer exists when the client sends a
        cancel command, or the consumer has been cancelled for
        other reasons, this command has no effect.
    PARAMETERS:
        consumer_tag: shortstr
            consumer tag
            Identifier for the consumer, valid within the current
            connection.
            RULE:
                The consumer tag is valid only within the channel
                from which the consumer was created. I.e. a client
                MUST NOT create a consumer in one channel and then
                use it in another.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
    """
    if self.connection is not None:
        self.no_ack_consumers.discard(consumer_tag)
        args = AMQPWriter()
        args.write_shortstr(consumer_tag)
        args.write_bit(nowait)
        self._send_method((60, 30), args)
        return self.wait(allowed_methods=[
            (60, 31),  # Channel.basic_cancel_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_consume">
    <p>def <span class="ident">basic_consume</span>(</p><p>self, queue=&#39;&#39;, consumer_tag=&#39;&#39;, no_local=False, no_ack=False, exclusive=False, nowait=False, callback=None, arguments=None, on_cancel=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Start a queue consumer</p>
<p>This method asks the server to start a "consumer", which is a
transient request for messages from a specific queue.
Consumers last as long as the channel they were created on, or
until the client cancels them.</p>
<p>RULE:</p>
<pre><code>The server SHOULD support at least 16 consumers per queue,
unless the queue was declared as private, and ideally,
impose no limit except as defined by available resources.
</code></pre>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    Specifies the name of the queue to consume from.  If
    the queue name is null, refers to the current queue
    for the channel, which is the last declared queue.

    RULE:

        If the client did not previously declare a queue,
        and the queue name in this method is empty, the
        server MUST raise a connection exception with
        reply code 530 (not allowed).

consumer_tag: shortstr

    Specifies the identifier for the consumer. The
    consumer tag is local to a connection, so two clients
    can use the same consumer tags. If this field is empty
    the server will generate a unique tag.

    RULE:

        The tag MUST NOT refer to an existing consumer. If
        the client attempts to create two consumers with
        the same non-empty tag the server MUST raise a
        connection exception with reply code 530 (not
        allowed).

no_local: boolean

    do not deliver own messages

    If the no-local field is set the server will not send
    messages to the client that published them.

no_ack: boolean

    no acknowledgement needed

    If this field is set the server does not expect
    acknowledgments for messages.  That is, when a message
    is delivered to the client the server automatically and
    silently acknowledges it on behalf of the client.  This
    functionality increases performance but at the cost of
    reliability.  Messages can get lost if a client dies
    before it can deliver them to the application.

exclusive: boolean

    request exclusive access

    Request exclusive consumer access, meaning only this
    consumer can access the queue.

    RULE:

        If the server cannot grant exclusive access to the
        queue when asked, - because there are other
        consumers active - it MUST raise a channel
        exception with return code 403 (access refused).

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.

callback: Python callable

    function/method called with each delivered message

    For each message delivered by the broker, the
    callable will be called with a Message object
    as the single argument.  If no callable is specified,
    messages are quietly discarded, no_ack should probably
    be set to True in that case.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_consume', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_consume" class="source">
    <pre><code>def basic_consume(self, queue='', consumer_tag='', no_local=False,
                  no_ack=False, exclusive=False, nowait=False,
                  callback=None, arguments=None, on_cancel=None):
    """Start a queue consumer
    This method asks the server to start a "consumer", which is a
    transient request for messages from a specific queue.
    Consumers last as long as the channel they were created on, or
    until the client cancels them.
    RULE:
        The server SHOULD support at least 16 consumers per queue,
        unless the queue was declared as private, and ideally,
        impose no limit except as defined by available resources.
    PARAMETERS:
        queue: shortstr
            Specifies the name of the queue to consume from.  If
            the queue name is null, refers to the current queue
            for the channel, which is the last declared queue.
            RULE:
                If the client did not previously declare a queue,
                and the queue name in this method is empty, the
                server MUST raise a connection exception with
                reply code 530 (not allowed).
        consumer_tag: shortstr
            Specifies the identifier for the consumer. The
            consumer tag is local to a connection, so two clients
            can use the same consumer tags. If this field is empty
            the server will generate a unique tag.
            RULE:
                The tag MUST NOT refer to an existing consumer. If
                the client attempts to create two consumers with
                the same non-empty tag the server MUST raise a
                connection exception with reply code 530 (not
                allowed).
        no_local: boolean
            do not deliver own messages
            If the no-local field is set the server will not send
            messages to the client that published them.
        no_ack: boolean
            no acknowledgement needed
            If this field is set the server does not expect
            acknowledgments for messages.  That is, when a message
            is delivered to the client the server automatically and
            silently acknowledges it on behalf of the client.  This
            functionality increases performance but at the cost of
            reliability.  Messages can get lost if a client dies
            before it can deliver them to the application.
        exclusive: boolean
            request exclusive access
            Request exclusive consumer access, meaning only this
            consumer can access the queue.
            RULE:
                If the server cannot grant exclusive access to the
                queue when asked, - because there are other
                consumers active - it MUST raise a channel
                exception with return code 403 (access refused).
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
        callback: Python callable
            function/method called with each delivered message
            For each message delivered by the broker, the
            callable will be called with a Message object
            as the single argument.  If no callable is specified,
            messages are quietly discarded, no_ack should probably
            be set to True in that case.
    """
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_shortstr(consumer_tag)
    args.write_bit(no_local)
    args.write_bit(no_ack)
    args.write_bit(exclusive)
    args.write_bit(nowait)
    args.write_table(arguments or {})
    self._send_method((60, 20), args)
    if not nowait:
        consumer_tag = self.wait(allowed_methods=[
            (60, 21),  # Channel.basic_consume_ok
        ])
    self.callbacks[consumer_tag] = callback
    if on_cancel:
        self.cancel_callbacks[consumer_tag] = on_cancel
    if no_ack:
        self.no_ack_consumers.add(consumer_tag)
    return consumer_tag
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_get">
    <p>def <span class="ident">basic_get</span>(</p><p>self, queue=&#39;&#39;, no_ack=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Direct access to a queue</p>
<p>This method provides a direct access to the messages in a
queue using a synchronous dialogue that is designed for
specific types of application where synchronous functionality
is more important than performance.</p>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    Specifies the name of the queue to consume from.  If
    the queue name is null, refers to the current queue
    for the channel, which is the last declared queue.

    RULE:

        If the client did not previously declare a queue,
        and the queue name in this method is empty, the
        server MUST raise a connection exception with
        reply code 530 (not allowed).

no_ack: boolean

    no acknowledgement needed

    If this field is set the server does not expect
    acknowledgments for messages.  That is, when a message
    is delivered to the client the server automatically and
    silently acknowledges it on behalf of the client.  This
    functionality increases performance but at the cost of
    reliability.  Messages can get lost if a client dies
    before it can deliver them to the application.
</code></pre>
<p>Non-blocking, returns a message object, or None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_get', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_get" class="source">
    <pre><code>def basic_get(self, queue='', no_ack=False):
    """Direct access to a queue
    This method provides a direct access to the messages in a
    queue using a synchronous dialogue that is designed for
    specific types of application where synchronous functionality
    is more important than performance.
    PARAMETERS:
        queue: shortstr
            Specifies the name of the queue to consume from.  If
            the queue name is null, refers to the current queue
            for the channel, which is the last declared queue.
            RULE:
                If the client did not previously declare a queue,
                and the queue name in this method is empty, the
                server MUST raise a connection exception with
                reply code 530 (not allowed).
        no_ack: boolean
            no acknowledgement needed
            If this field is set the server does not expect
            acknowledgments for messages.  That is, when a message
            is delivered to the client the server automatically and
            silently acknowledges it on behalf of the client.  This
            functionality increases performance but at the cost of
            reliability.  Messages can get lost if a client dies
            before it can deliver them to the application.
    Non-blocking, returns a message object, or None.
    """
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_bit(no_ack)
    self._send_method((60, 70), args)
    return self.wait(allowed_methods=[
        (60, 71),  # Channel.basic_get_ok
        (60, 72),  # Channel.basic_get_empty
    ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_publish">
    <p>def <span class="ident">basic_publish</span>(</p><p>self, msg, exchange=&#39;&#39;, routing_key=&#39;&#39;, mandatory=False, immediate=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Publish a message</p>
<p>This method publishes a message to a specific exchange. The
message will be routed to queues as defined by the exchange
configuration and distributed to any active consumers when the
transaction, if any, is committed.</p>
<p>PARAMETERS:
    exchange: shortstr</p>
<pre><code>    Specifies the name of the exchange to publish to.  The
    exchange name can be empty, meaning the default
    exchange.  If the exchange name is specified, and that
    exchange does not exist, the server will raise a
    channel exception.

    RULE:

        The server MUST accept a blank exchange name to
        mean the default exchange.

    RULE:

        The exchange MAY refuse basic content in which
        case it MUST raise a channel exception with reply
        code 540 (not implemented).

routing_key: shortstr

    Message routing key

    Specifies the routing key for the message.  The
    routing key is used for routing messages depending on
    the exchange configuration.

mandatory: boolean

    indicate mandatory routing

    This flag tells the server how to react if the message
    cannot be routed to a queue.  If this flag is True, the
    server will return an unroutable message with a Return
    method.  If this flag is False, the server silently
    drops the message.

    RULE:

        The server SHOULD implement the mandatory flag.

immediate: boolean

    request immediate delivery

    This flag tells the server how to react if the message
    cannot be routed to a queue consumer immediately.  If
    this flag is set, the server will return an
    undeliverable message with a Return method. If this
    flag is zero, the server will queue the message, but
    with no guarantee that it will ever be consumed.

    RULE:

        The server SHOULD implement the immediate flag.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_publish', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_publish" class="source">
    <pre><code>def _basic_publish(self, msg, exchange='', routing_key='',
                   mandatory=False, immediate=False):
    """Publish a message
    This method publishes a message to a specific exchange. The
    message will be routed to queues as defined by the exchange
    configuration and distributed to any active consumers when the
    transaction, if any, is committed.
    PARAMETERS:
        exchange: shortstr
            Specifies the name of the exchange to publish to.  The
            exchange name can be empty, meaning the default
            exchange.  If the exchange name is specified, and that
            exchange does not exist, the server will raise a
            channel exception.
            RULE:
                The server MUST accept a blank exchange name to
                mean the default exchange.
            RULE:
                The exchange MAY refuse basic content in which
                case it MUST raise a channel exception with reply
                code 540 (not implemented).
        routing_key: shortstr
            Message routing key
            Specifies the routing key for the message.  The
            routing key is used for routing messages depending on
            the exchange configuration.
        mandatory: boolean
            indicate mandatory routing
            This flag tells the server how to react if the message
            cannot be routed to a queue.  If this flag is True, the
            server will return an unroutable message with a Return
            method.  If this flag is False, the server silently
            drops the message.
            RULE:
                The server SHOULD implement the mandatory flag.
        immediate: boolean
            request immediate delivery
            This flag tells the server how to react if the message
            cannot be routed to a queue consumer immediately.  If
            this flag is set, the server will return an
            undeliverable message with a Return method. If this
            flag is zero, the server will queue the message, but
            with no guarantee that it will ever be consumed.
            RULE:
                The server SHOULD implement the immediate flag.
    """
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(exchange)
    args.write_shortstr(routing_key)
    args.write_bit(mandatory)
    args.write_bit(immediate)
    self._send_method((60, 40), args, msg)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_publish_confirm">
    <p>def <span class="ident">basic_publish_confirm</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_publish_confirm', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_publish_confirm" class="source">
    <pre><code>def basic_publish_confirm(self, *args, **kwargs):
    if not self._confirm_selected:
        self._confirm_selected = True
        self.confirm_select()
    ret = self._basic_publish(*args, **kwargs)
    # Basic.Ack / Basic.Nack
    self.wait([(60, 80), (60, 120)])
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_qos">
    <p>def <span class="ident">basic_qos</span>(</p><p>self, prefetch_size, prefetch_count, a_global)</p>
    </div>
    

    
  
    <div class="desc"><p>Specify quality of service</p>
<p>This method requests a specific quality of service.  The QoS
can be specified for the current channel or for all channels
on the connection.  The particular properties and semantics of
a qos method always depend on the content class semantics.
Though the qos method could in principle apply to both peers,
it is currently meaningful only for the server.</p>
<p>PARAMETERS:
    prefetch_size: long</p>
<pre><code>    prefetch window in octets

    The client can request that messages be sent in
    advance so that when the client finishes processing a
    message, the following message is already held
    locally, rather than needing to be sent down the
    channel.  Prefetching gives a performance improvement.
    This field specifies the prefetch window size in
    octets.  The server will send a message in advance if
    it is equal to or smaller in size than the available
    prefetch size (and also falls into other prefetch
    limits). May be set to zero, meaning "no specific
    limit", although other prefetch limits may still
    apply. The prefetch-size is ignored if the no-ack
    option is set.

    RULE:

        The server MUST ignore this setting when the
        client is not processing any messages - i.e. the
        prefetch size does not limit the transfer of
        single messages to a client, only the sending in
        advance of more messages while the client still
        has one or more unacknowledged messages.

prefetch_count: short

    prefetch window in messages

    Specifies a prefetch window in terms of whole
    messages.  This field may be used in combination with
    the prefetch-size field; a message will only be sent
    in advance if both prefetch windows (and those at the
    channel and connection level) allow it. The prefetch-
    count is ignored if the no-ack option is set.

    RULE:

        The server MAY send less data in advance than
        allowed by the client's specified prefetch windows
        but it MUST NOT send more.

a_global: boolean

    apply to entire connection

    By default the QoS settings apply to the current
    channel only.  If this field is set, they are applied
    to the entire connection.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_qos', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_qos" class="source">
    <pre><code>def basic_qos(self, prefetch_size, prefetch_count, a_global):
    """Specify quality of service
    This method requests a specific quality of service.  The QoS
    can be specified for the current channel or for all channels
    on the connection.  The particular properties and semantics of
    a qos method always depend on the content class semantics.
    Though the qos method could in principle apply to both peers,
    it is currently meaningful only for the server.
    PARAMETERS:
        prefetch_size: long
            prefetch window in octets
            The client can request that messages be sent in
            advance so that when the client finishes processing a
            message, the following message is already held
            locally, rather than needing to be sent down the
            channel.  Prefetching gives a performance improvement.
            This field specifies the prefetch window size in
            octets.  The server will send a message in advance if
            it is equal to or smaller in size than the available
            prefetch size (and also falls into other prefetch
            limits). May be set to zero, meaning "no specific
            limit", although other prefetch limits may still
            apply. The prefetch-size is ignored if the no-ack
            option is set.
            RULE:
                The server MUST ignore this setting when the
                client is not processing any messages - i.e. the
                prefetch size does not limit the transfer of
                single messages to a client, only the sending in
                advance of more messages while the client still
                has one or more unacknowledged messages.
        prefetch_count: short
            prefetch window in messages
            Specifies a prefetch window in terms of whole
            messages.  This field may be used in combination with
            the prefetch-size field; a message will only be sent
            in advance if both prefetch windows (and those at the
            channel and connection level) allow it. The prefetch-
            count is ignored if the no-ack option is set.
            RULE:
                The server MAY send less data in advance than
                allowed by the client's specified prefetch windows
                but it MUST NOT send more.
        a_global: boolean
            apply to entire connection
            By default the QoS settings apply to the current
            channel only.  If this field is set, they are applied
            to the entire connection.
    """
    args = AMQPWriter()
    args.write_long(prefetch_size)
    args.write_short(prefetch_count)
    args.write_bit(a_global)
    self._send_method((60, 10), args)
    return self.wait(allowed_methods=[
        (60, 11),  # Channel.basic_qos_ok
    ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_recover">
    <p>def <span class="ident">basic_recover</span>(</p><p>self, requeue=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Redeliver unacknowledged messages</p>
<p>This method asks the broker to redeliver all unacknowledged
messages on a specified channel. Zero or more messages may be
redelivered.  This method is only allowed on non-transacted
channels.</p>
<p>RULE:</p>
<pre><code>The server MUST set the redelivered flag on all messages
that are resent.
</code></pre>
<p>RULE:</p>
<pre><code>The server MUST raise a channel exception if this is
called on a transacted channel.
</code></pre>
<p>PARAMETERS:
    requeue: boolean</p>
<pre><code>    requeue the message

    If this field is False, the message will be redelivered
    to the original recipient.  If this field is True, the
    server will attempt to requeue the message,
    potentially then delivering it to an alternative
    subscriber.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_recover', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_recover" class="source">
    <pre><code>def basic_recover(self, requeue=False):
    """Redeliver unacknowledged messages
    This method asks the broker to redeliver all unacknowledged
    messages on a specified channel. Zero or more messages may be
    redelivered.  This method is only allowed on non-transacted
    channels.
    RULE:
        The server MUST set the redelivered flag on all messages
        that are resent.
    RULE:
        The server MUST raise a channel exception if this is
        called on a transacted channel.
    PARAMETERS:
        requeue: boolean
            requeue the message
            If this field is False, the message will be redelivered
            to the original recipient.  If this field is True, the
            server will attempt to requeue the message,
            potentially then delivering it to an alternative
            subscriber.
    """
    args = AMQPWriter()
    args.write_bit(requeue)
    self._send_method((60, 110), args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_recover_async">
    <p>def <span class="ident">basic_recover_async</span>(</p><p>self, requeue=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_recover_async', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_recover_async" class="source">
    <pre><code>def basic_recover_async(self, requeue=False):
    args = AMQPWriter()
    args.write_bit(requeue)
    self._send_method((60, 100), args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.basic_reject">
    <p>def <span class="ident">basic_reject</span>(</p><p>self, delivery_tag, requeue)</p>
    </div>
    

    
  
    <div class="desc"><p>Reject an incoming message</p>
<p>This method allows a client to reject a message.  It can be
used to interrupt and cancel large incoming messages, or
return untreatable messages to their original queue.</p>
<p>RULE:</p>
<pre><code>The server SHOULD be capable of accepting and process the
Reject method while sending message content with a Deliver
or Get-Ok method.  I.e. the server should read and process
incoming methods while sending output frames.  To cancel a
partially-send content, the server sends a content body
frame of size 1 (i.e. with no data except the frame-end
octet).
</code></pre>
<p>RULE:</p>
<pre><code>The server SHOULD interpret this method as meaning that
the client is unable to process the message at this time.
</code></pre>
<p>RULE:</p>
<pre><code>A client MUST NOT use this method as a means of selecting
messages to process.  A rejected message MAY be discarded
or dead-lettered, not necessarily passed to another
client.
</code></pre>
<p>PARAMETERS:
    delivery_tag: longlong</p>
<pre><code>    server-assigned delivery tag

    The server-assigned and channel-specific delivery tag

    RULE:

        The delivery tag is valid only within the channel
        from which the message was received.  I.e. a client
        MUST NOT receive a message on one channel and then
        acknowledge it on another.

    RULE:

        The server MUST NOT use a zero value for delivery
        tags.  Zero is reserved for client use, meaning "all
        messages so far received".

requeue: boolean

    requeue the message

    If this field is False, the message will be discarded.
    If this field is True, the server will attempt to
    requeue the message.

    RULE:

        The server MUST NOT deliver the message to the
        same client within the context of the current
        channel.  The recommended strategy is to attempt
        to deliver the message to an alternative consumer,
        and if that is not possible, to move the message
        to a dead-letter queue.  The server MAY use more
        sophisticated tracking to hold the message on the
        queue and redeliver it to the same client at a
        later stage.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.basic_reject', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.basic_reject" class="source">
    <pre><code>def basic_reject(self, delivery_tag, requeue):
    """Reject an incoming message
    This method allows a client to reject a message.  It can be
    used to interrupt and cancel large incoming messages, or
    return untreatable messages to their original queue.
    RULE:
        The server SHOULD be capable of accepting and process the
        Reject method while sending message content with a Deliver
        or Get-Ok method.  I.e. the server should read and process
        incoming methods while sending output frames.  To cancel a
        partially-send content, the server sends a content body
        frame of size 1 (i.e. with no data except the frame-end
        octet).
    RULE:
        The server SHOULD interpret this method as meaning that
        the client is unable to process the message at this time.
    RULE:
        A client MUST NOT use this method as a means of selecting
        messages to process.  A rejected message MAY be discarded
        or dead-lettered, not necessarily passed to another
        client.
    PARAMETERS:
        delivery_tag: longlong
            server-assigned delivery tag
            The server-assigned and channel-specific delivery tag
            RULE:
                The delivery tag is valid only within the channel
                from which the message was received.  I.e. a client
                MUST NOT receive a message on one channel and then
                acknowledge it on another.
            RULE:
                The server MUST NOT use a zero value for delivery
                tags.  Zero is reserved for client use, meaning "all
                messages so far received".
        requeue: boolean
            requeue the message
            If this field is False, the message will be discarded.
            If this field is True, the server will attempt to
            requeue the message.
            RULE:
                The server MUST NOT deliver the message to the
                same client within the context of the current
                channel.  The recommended strategy is to attempt
                to deliver the message to an alternative consumer,
                and if that is not possible, to move the message
                to a dead-letter queue.  The server MAY use more
                sophisticated tracking to hold the message on the
                queue and redeliver it to the same client at a
                later stage.
    """
    args = AMQPWriter()
    args.write_longlong(delivery_tag)
    args.write_bit(requeue)
    self._send_method((60, 90), args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.close">
    <p>def <span class="ident">close</span>(</p><p>self, reply_code=0, reply_text=&#39;&#39;, method_sig=(0, 0))</p>
    </div>
    

    
  
    <div class="desc"><p>Request a channel close</p>
<p>This method indicates that the sender wants to close the
channel. This may be due to internal conditions (e.g. a forced
shut-down) or due to an error handling a specific method, i.e.
an exception.  When a close is due to an exception, the sender
provides the class and method id of the method which caused
the exception.</p>
<p>RULE:</p>
<pre><code>After sending this method any received method except
Channel.Close-OK MUST be discarded.
</code></pre>
<p>RULE:</p>
<pre><code>The peer sending this method MAY use a counter or timeout
to detect failure of the other peer to respond correctly
with Channel.Close-OK..
</code></pre>
<p>PARAMETERS:
    reply_code: short</p>
<pre><code>    The reply code. The AMQ reply codes are defined in AMQ
    RFC 011.

reply_text: shortstr

    The localised reply text.  This text can be logged as an
    aid to resolving issues.

class_id: short

    failing method class

    When the close is provoked by a method exception, this
    is the class of the method.

method_id: short

    failing method ID

    When the close is provoked by a method exception, this
    is the ID of the method.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.close', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.close" class="source">
    <pre><code>def close(self, reply_code=0, reply_text='', method_sig=(0, 0)):
    """Request a channel close
    This method indicates that the sender wants to close the
    channel. This may be due to internal conditions (e.g. a forced
    shut-down) or due to an error handling a specific method, i.e.
    an exception.  When a close is due to an exception, the sender
    provides the class and method id of the method which caused
    the exception.
    RULE:
        After sending this method any received method except
        Channel.Close-OK MUST be discarded.
    RULE:
        The peer sending this method MAY use a counter or timeout
        to detect failure of the other peer to respond correctly
        with Channel.Close-OK..
    PARAMETERS:
        reply_code: short
            The reply code. The AMQ reply codes are defined in AMQ
            RFC 011.
        reply_text: shortstr
            The localised reply text.  This text can be logged as an
            aid to resolving issues.
        class_id: short
            failing method class
            When the close is provoked by a method exception, this
            is the class of the method.
        method_id: short
            failing method ID
            When the close is provoked by a method exception, this
            is the ID of the method.
    """
    try:
        if not self.is_open or self.connection is None:
            return
        args = AMQPWriter()
        args.write_short(reply_code)
        args.write_shortstr(reply_text)
        args.write_short(method_sig[0])  # class_id
        args.write_short(method_sig[1])  # method_id
        self._send_method((20, 40), args)
        return self.wait(allowed_methods=[
            (20, 40),  # Channel.close
            (20, 41),  # Channel.close_ok
        ])
    except (socket.timeout, socket.error) as e:
        # no point in waiting anymore
        if isinstance(e, socket.timeout):
            try:
                self.connection.sock.settimeout(0.1)
            except:
                pass
        # lack of communication should not prevent tidy-up
        self._do_close()
    finally:
        self.connection = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.confirm_select">
    <p>def <span class="ident">confirm_select</span>(</p><p>self, nowait=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Enables publisher confirms for this channel (an RabbitMQ
extension).</p>
<p>Can now be used if the channel is in transactional mode.</p>
<p>:param nowait:
    If set, the server will not respond to the method.
    The client should not wait for a reply method. If the
    server could not complete the method it will raise a channel
    or connection exception.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.confirm_select', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.confirm_select" class="source">
    <pre><code>def confirm_select(self, nowait=False):
    """Enables publisher confirms for this channel (an RabbitMQ
    extension).
    Can now be used if the channel is in transactional mode.
    :param nowait:
        If set, the server will not respond to the method.
        The client should not wait for a reply method. If the
        server could not complete the method it will raise a channel
        or connection exception.
    """
    args = AMQPWriter()
    args.write_bit(nowait)
    self._send_method((85, 10), args)
    if not nowait:
        self.wait(allowed_methods=[
            (85, 11),  # Confirm.select_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.dispatch_method">
    <p>def <span class="ident">dispatch_method</span>(</p><p>self, method_sig, args, content)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.dispatch_method', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.dispatch_method" class="source">
    <pre><code>def dispatch_method(self, method_sig, args, content):
    if content and \
            self.auto_encode_decode and \
            hasattr(content, 'content_encoding'):
        try:
            content.body = content.body.decode(content.content_encoding)
        except Exception:
            pass
    try:
        amqp_method = self._METHOD_MAP[method_sig]
    except KeyError:
        raise AMQPNotImplementedError(
            'Unknown AMQP method {0!r}'.format(method_sig))
    if content is None:
        return amqp_method(self, args)
    else:
        return amqp_method(self, args, content)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.exchange_bind">
    <p>def <span class="ident">exchange_bind</span>(</p><p>self, destination, source=&#39;&#39;, routing_key=&#39;&#39;, nowait=False, arguments=None)</p>
    </div>
    

    
  
    <div class="desc"><p>This method binds an exchange to an exchange.</p>
<p>RULE:</p>
<pre><code>A server MUST allow and ignore duplicate bindings - that
is, two or more bind methods for a specific exchanges,
with identical arguments - without treating these as an
error.
</code></pre>
<p>RULE:</p>
<pre><code>A server MUST allow cycles of exchange bindings to be
created including allowing an exchange to be bound to
itself.
</code></pre>
<p>RULE:</p>
<pre><code>A server MUST not deliver the same message more than once
to a destination exchange, even if the topology of
exchanges and bindings results in multiple (even infinite)
routes to that exchange.
</code></pre>
<p>PARAMETERS:
    reserved-1: short</p>
<pre><code>destination: shortstr

    Specifies the name of the destination exchange to
    bind.

    RULE:

        A client MUST NOT be allowed to bind a non-
        existent destination exchange.

    RULE:

        The server MUST accept a blank exchange name to
        mean the default exchange.

source: shortstr

    Specifies the name of the source exchange to bind.

    RULE:

        A client MUST NOT be allowed to bind a non-
        existent source exchange.

    RULE:

        The server MUST accept a blank exchange name to
        mean the default exchange.

routing-key: shortstr

    Specifies the routing key for the binding. The routing
    key is used for routing messages depending on the
    exchange configuration. Not all exchanges use a
    routing key - refer to the specific exchange
    documentation.

no-wait: bit

arguments: table

    A set of arguments for the binding. The syntax and
    semantics of these arguments depends on the exchange
    class.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.exchange_bind', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.exchange_bind" class="source">
    <pre><code>def exchange_bind(self, destination, source='', routing_key='',
                  nowait=False, arguments=None):
    """This method binds an exchange to an exchange.
    RULE:
        A server MUST allow and ignore duplicate bindings - that
        is, two or more bind methods for a specific exchanges,
        with identical arguments - without treating these as an
        error.
    RULE:
        A server MUST allow cycles of exchange bindings to be
        created including allowing an exchange to be bound to
        itself.
    RULE:
        A server MUST not deliver the same message more than once
        to a destination exchange, even if the topology of
        exchanges and bindings results in multiple (even infinite)
        routes to that exchange.
    PARAMETERS:
        reserved-1: short
        destination: shortstr
            Specifies the name of the destination exchange to
            bind.
            RULE:
                A client MUST NOT be allowed to bind a non-
                existent destination exchange.
            RULE:
                The server MUST accept a blank exchange name to
                mean the default exchange.
        source: shortstr
            Specifies the name of the source exchange to bind.
            RULE:
                A client MUST NOT be allowed to bind a non-
                existent source exchange.
            RULE:
                The server MUST accept a blank exchange name to
                mean the default exchange.
        routing-key: shortstr
            Specifies the routing key for the binding. The routing
            key is used for routing messages depending on the
            exchange configuration. Not all exchanges use a
            routing key - refer to the specific exchange
            documentation.
        no-wait: bit
        arguments: table
            A set of arguments for the binding. The syntax and
            semantics of these arguments depends on the exchange
            class.
    """
    arguments = {} if arguments is None else arguments
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(destination)
    args.write_shortstr(source)
    args.write_shortstr(routing_key)
    args.write_bit(nowait)
    args.write_table(arguments)
    self._send_method((40, 30), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (40, 31),  # Channel.exchange_bind_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.exchange_declare">
    <p>def <span class="ident">exchange_declare</span>(</p><p>self, exchange, type, passive=False, durable=False, auto_delete=True, nowait=False, arguments=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Declare exchange, create if needed</p>
<p>This method creates an exchange if it does not already exist,
and if the exchange exists, verifies that it is of the correct
and expected class.</p>
<p>RULE:</p>
<pre><code>The server SHOULD support a minimum of 16 exchanges per
virtual host and ideally, impose no limit except as
defined by available resources.
</code></pre>
<p>PARAMETERS:
    exchange: shortstr</p>
<pre><code>    RULE:

        Exchange names starting with "amq." are reserved
        for predeclared and standardised exchanges.  If
        the client attempts to create an exchange starting
        with "amq.", the server MUST raise a channel
        exception with reply code 403 (access refused).

type: shortstr

    exchange type

    Each exchange belongs to one of a set of exchange
    types implemented by the server.  The exchange types
    define the functionality of the exchange - i.e. how
    messages are routed through it.  It is not valid or
    meaningful to attempt to change the type of an
    existing exchange.

    RULE:

        If the exchange already exists with a different
        type, the server MUST raise a connection exception
        with a reply code 507 (not allowed).

    RULE:

        If the server does not support the requested
        exchange type it MUST raise a connection exception
        with a reply code 503 (command invalid).

passive: boolean

    do not create exchange

    If set, the server will not create the exchange.  The
    client can use this to check whether an exchange
    exists without modifying the server state.

    RULE:

        If set, and the exchange does not already exist,
        the server MUST raise a channel exception with
        reply code 404 (not found).

durable: boolean

    request a durable exchange

    If set when creating a new exchange, the exchange will
    be marked as durable.  Durable exchanges remain active
    when a server restarts. Non-durable exchanges
    (transient exchanges) are purged if/when a server
    restarts.

    RULE:

        The server MUST support both durable and transient
        exchanges.

    RULE:

        The server MUST ignore the durable field if the
        exchange already exists.

auto_delete: boolean

    auto-delete when unused

    If set, the exchange is deleted when all queues have
    finished using it.

    RULE:

        The server SHOULD allow for a reasonable delay
        between the point when it determines that an
        exchange is not being used (or no longer used),
        and the point when it deletes the exchange.  At
        the least it must allow a client to create an
        exchange and then bind a queue to it, with a small
        but non-zero delay between these two actions.

    RULE:

        The server MUST ignore the auto-delete field if
        the exchange already exists.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.

arguments: table

    arguments for declaration

    A set of arguments for the declaration. The syntax and
    semantics of these arguments depends on the server
    implementation.  This field is ignored if passive is
    True.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.exchange_declare', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.exchange_declare" class="source">
    <pre><code>def exchange_declare(self, exchange, type, passive=False, durable=False,
                     auto_delete=True, nowait=False, arguments=None):
    """Declare exchange, create if needed
    This method creates an exchange if it does not already exist,
    and if the exchange exists, verifies that it is of the correct
    and expected class.
    RULE:
        The server SHOULD support a minimum of 16 exchanges per
        virtual host and ideally, impose no limit except as
        defined by available resources.
    PARAMETERS:
        exchange: shortstr
            RULE:
                Exchange names starting with "amq." are reserved
                for predeclared and standardised exchanges.  If
                the client attempts to create an exchange starting
                with "amq.", the server MUST raise a channel
                exception with reply code 403 (access refused).
        type: shortstr
            exchange type
            Each exchange belongs to one of a set of exchange
            types implemented by the server.  The exchange types
            define the functionality of the exchange - i.e. how
            messages are routed through it.  It is not valid or
            meaningful to attempt to change the type of an
            existing exchange.
            RULE:
                If the exchange already exists with a different
                type, the server MUST raise a connection exception
                with a reply code 507 (not allowed).
            RULE:
                If the server does not support the requested
                exchange type it MUST raise a connection exception
                with a reply code 503 (command invalid).
        passive: boolean
            do not create exchange
            If set, the server will not create the exchange.  The
            client can use this to check whether an exchange
            exists without modifying the server state.
            RULE:
                If set, and the exchange does not already exist,
                the server MUST raise a channel exception with
                reply code 404 (not found).
        durable: boolean
            request a durable exchange
            If set when creating a new exchange, the exchange will
            be marked as durable.  Durable exchanges remain active
            when a server restarts. Non-durable exchanges
            (transient exchanges) are purged if/when a server
            restarts.
            RULE:
                The server MUST support both durable and transient
                exchanges.
            RULE:
                The server MUST ignore the durable field if the
                exchange already exists.
        auto_delete: boolean
            auto-delete when unused
            If set, the exchange is deleted when all queues have
            finished using it.
            RULE:
                The server SHOULD allow for a reasonable delay
                between the point when it determines that an
                exchange is not being used (or no longer used),
                and the point when it deletes the exchange.  At
                the least it must allow a client to create an
                exchange and then bind a queue to it, with a small
                but non-zero delay between these two actions.
            RULE:
                The server MUST ignore the auto-delete field if
                the exchange already exists.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
        arguments: table
            arguments for declaration
            A set of arguments for the declaration. The syntax and
            semantics of these arguments depends on the server
            implementation.  This field is ignored if passive is
            True.
    """
    arguments = {} if arguments is None else arguments
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(exchange)
    args.write_shortstr(type)
    args.write_bit(passive)
    args.write_bit(durable)
    args.write_bit(auto_delete)
    args.write_bit(False)  # internal: deprecated
    args.write_bit(nowait)
    args.write_table(arguments)
    self._send_method((40, 10), args)
    if auto_delete:
        warn(VDeprecationWarning(EXCHANGE_AUTODELETE_DEPRECATED))
    if not nowait:
        return self.wait(allowed_methods=[
            (40, 11),  # Channel.exchange_declare_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.exchange_delete">
    <p>def <span class="ident">exchange_delete</span>(</p><p>self, exchange, if_unused=False, nowait=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete an exchange</p>
<p>This method deletes an exchange.  When an exchange is deleted
all queue bindings on the exchange are cancelled.</p>
<p>PARAMETERS:
    exchange: shortstr</p>
<pre><code>    RULE:

        The exchange MUST exist. Attempting to delete a
        non-existing exchange causes a channel exception.

if_unused: boolean

    delete only if unused

    If set, the server will only delete the exchange if it
    has no queue bindings. If the exchange has queue
    bindings the server does not delete it but raises a
    channel exception instead.

    RULE:

        If set, the server SHOULD delete the exchange but
        only if it has no queue bindings.

    RULE:

        If set, the server SHOULD raise a channel
        exception if the exchange is in use.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.exchange_delete', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.exchange_delete" class="source">
    <pre><code>def exchange_delete(self, exchange, if_unused=False, nowait=False):
    """Delete an exchange
    This method deletes an exchange.  When an exchange is deleted
    all queue bindings on the exchange are cancelled.
    PARAMETERS:
        exchange: shortstr
            RULE:
                The exchange MUST exist. Attempting to delete a
                non-existing exchange causes a channel exception.
        if_unused: boolean
            delete only if unused
            If set, the server will only delete the exchange if it
            has no queue bindings. If the exchange has queue
            bindings the server does not delete it but raises a
            channel exception instead.
            RULE:
                If set, the server SHOULD delete the exchange but
                only if it has no queue bindings.
            RULE:
                If set, the server SHOULD raise a channel
                exception if the exchange is in use.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
    """
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(exchange)
    args.write_bit(if_unused)
    args.write_bit(nowait)
    self._send_method((40, 20), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (40, 21),  # Channel.exchange_delete_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.exchange_unbind">
    <p>def <span class="ident">exchange_unbind</span>(</p><p>self, destination, source=&#39;&#39;, routing_key=&#39;&#39;, nowait=False, arguments=None)</p>
    </div>
    

    
  
    <div class="desc"><p>This method unbinds an exchange from an exchange.</p>
<p>RULE:</p>
<pre><code>If a unbind fails, the server MUST raise a connection
exception.
</code></pre>
<p>PARAMETERS:
    reserved-1: short</p>
<pre><code>destination: shortstr

    Specifies the name of the destination exchange to
    unbind.

    RULE:

        The client MUST NOT attempt to unbind an exchange
        that does not exist from an exchange.

    RULE:

        The server MUST accept a blank exchange name to
        mean the default exchange.

source: shortstr

    Specifies the name of the source exchange to unbind.

    RULE:

        The client MUST NOT attempt to unbind an exchange
        from an exchange that does not exist.

    RULE:

        The server MUST accept a blank exchange name to
        mean the default exchange.

routing-key: shortstr

    Specifies the routing key of the binding to unbind.

no-wait: bit

arguments: table

    Specifies the arguments of the binding to unbind.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.exchange_unbind', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.exchange_unbind" class="source">
    <pre><code>def exchange_unbind(self, destination, source='', routing_key='',
                    nowait=False, arguments=None):
    """This method unbinds an exchange from an exchange.
    RULE:
        If a unbind fails, the server MUST raise a connection
        exception.
    PARAMETERS:
        reserved-1: short
        destination: shortstr
            Specifies the name of the destination exchange to
            unbind.
            RULE:
                The client MUST NOT attempt to unbind an exchange
                that does not exist from an exchange.
            RULE:
                The server MUST accept a blank exchange name to
                mean the default exchange.
        source: shortstr
            Specifies the name of the source exchange to unbind.
            RULE:
                The client MUST NOT attempt to unbind an exchange
                from an exchange that does not exist.
            RULE:
                The server MUST accept a blank exchange name to
                mean the default exchange.
        routing-key: shortstr
            Specifies the routing key of the binding to unbind.
        no-wait: bit
        arguments: table
            Specifies the arguments of the binding to unbind.
    """
    arguments = {} if arguments is None else arguments
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(destination)
    args.write_shortstr(source)
    args.write_shortstr(routing_key)
    args.write_bit(nowait)
    args.write_table(arguments)
    self._send_method((40, 40), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (40, 51),  # Channel.exchange_unbind_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.flow">
    <p>def <span class="ident">flow</span>(</p><p>self, active)</p>
    </div>
    

    
  
    <div class="desc"><p>Enable/disable flow from peer</p>
<p>This method asks the peer to pause or restart the flow of
content data. This is a simple flow-control mechanism that a
peer can use to avoid oveflowing its queues or otherwise
finding itself receiving more messages than it can process.
Note that this method is not intended for window control.  The
peer that receives a request to stop sending content should
finish sending the current content, if any, and then wait
until it receives a Flow restart method.</p>
<p>RULE:</p>
<pre><code>When a new channel is opened, it is active.  Some
applications assume that channels are inactive until
started.  To emulate this behaviour a client MAY open the
channel, then pause it.
</code></pre>
<p>RULE:</p>
<pre><code>When sending content data in multiple frames, a peer
SHOULD monitor the channel for incoming methods and
respond to a Channel.Flow as rapidly as possible.
</code></pre>
<p>RULE:</p>
<pre><code>A peer MAY use the Channel.Flow method to throttle
incoming content data for internal reasons, for example,
when exchangeing data over a slower connection.
</code></pre>
<p>RULE:</p>
<pre><code>The peer that requests a Channel.Flow method MAY
disconnect and/or ban a peer that does not respect the
request.
</code></pre>
<p>PARAMETERS:
    active: boolean</p>
<pre><code>    start/stop content frames

    If True, the peer starts sending content frames.  If
    False, the peer stops sending content frames.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.flow', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.flow" class="source">
    <pre><code>def flow(self, active):
    """Enable/disable flow from peer
    This method asks the peer to pause or restart the flow of
    content data. This is a simple flow-control mechanism that a
    peer can use to avoid oveflowing its queues or otherwise
    finding itself receiving more messages than it can process.
    Note that this method is not intended for window control.  The
    peer that receives a request to stop sending content should
    finish sending the current content, if any, and then wait
    until it receives a Flow restart method.
    RULE:
        When a new channel is opened, it is active.  Some
        applications assume that channels are inactive until
        started.  To emulate this behaviour a client MAY open the
        channel, then pause it.
    RULE:
        When sending content data in multiple frames, a peer
        SHOULD monitor the channel for incoming methods and
        respond to a Channel.Flow as rapidly as possible.
    RULE:
        A peer MAY use the Channel.Flow method to throttle
        incoming content data for internal reasons, for example,
        when exchangeing data over a slower connection.
    RULE:
        The peer that requests a Channel.Flow method MAY
        disconnect and/or ban a peer that does not respect the
        request.
    PARAMETERS:
        active: boolean
            start/stop content frames
            If True, the peer starts sending content frames.  If
            False, the peer stops sending content frames.
    """
    args = AMQPWriter()
    args.write_bit(active)
    self._send_method((20, 20), args)
    return self.wait(allowed_methods=[
        (20, 21),  # Channel.flow_ok
    ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.queue_bind">
    <p>def <span class="ident">queue_bind</span>(</p><p>self, queue, exchange=&#39;&#39;, routing_key=&#39;&#39;, nowait=False, arguments=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Bind queue to an exchange</p>
<p>This method binds a queue to an exchange.  Until a queue is
bound it will not receive any messages.  In a classic
messaging model, store-and-forward queues are bound to a dest
exchange and subscription queues are bound to a dest_wild
exchange.</p>
<p>RULE:</p>
<pre><code>A server MUST allow ignore duplicate bindings - that is,
two or more bind methods for a specific queue, with
identical arguments - without treating these as an error.
</code></pre>
<p>RULE:</p>
<pre><code>If a bind fails, the server MUST raise a connection
exception.
</code></pre>
<p>RULE:</p>
<pre><code>The server MUST NOT allow a durable queue to bind to a
transient exchange. If the client attempts this the server
MUST raise a channel exception.
</code></pre>
<p>RULE:</p>
<pre><code>Bindings for durable queues are automatically durable and
the server SHOULD restore such bindings after a server
restart.
</code></pre>
<p>RULE:</p>
<pre><code>The server SHOULD support at least 4 bindings per queue,
and ideally, impose no limit except as defined by
available resources.
</code></pre>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    Specifies the name of the queue to bind.  If the queue
    name is empty, refers to the current queue for the
    channel, which is the last declared queue.

    RULE:

        If the client did not previously declare a queue,
        and the queue name in this method is empty, the
        server MUST raise a connection exception with
        reply code 530 (not allowed).

    RULE:

        If the queue does not exist the server MUST raise
        a channel exception with reply code 404 (not
        found).

exchange: shortstr

    The name of the exchange to bind to.

    RULE:

        If the exchange does not exist the server MUST
        raise a channel exception with reply code 404 (not
        found).

routing_key: shortstr

    message routing key

    Specifies the routing key for the binding.  The
    routing key is used for routing messages depending on
    the exchange configuration. Not all exchanges use a
    routing key - refer to the specific exchange
    documentation.  If the routing key is empty and the
    queue name is empty, the routing key will be the
    current queue for the channel, which is the last
    declared queue.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.

arguments: table

    arguments for binding

    A set of arguments for the binding.  The syntax and
    semantics of these arguments depends on the exchange
    class.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.queue_bind', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.queue_bind" class="source">
    <pre><code>def queue_bind(self, queue, exchange='', routing_key='',
               nowait=False, arguments=None):
    """Bind queue to an exchange
    This method binds a queue to an exchange.  Until a queue is
    bound it will not receive any messages.  In a classic
    messaging model, store-and-forward queues are bound to a dest
    exchange and subscription queues are bound to a dest_wild
    exchange.
    RULE:
        A server MUST allow ignore duplicate bindings - that is,
        two or more bind methods for a specific queue, with
        identical arguments - without treating these as an error.
    RULE:
        If a bind fails, the server MUST raise a connection
        exception.
    RULE:
        The server MUST NOT allow a durable queue to bind to a
        transient exchange. If the client attempts this the server
        MUST raise a channel exception.
    RULE:
        Bindings for durable queues are automatically durable and
        the server SHOULD restore such bindings after a server
        restart.
    RULE:
        The server SHOULD support at least 4 bindings per queue,
        and ideally, impose no limit except as defined by
        available resources.
    PARAMETERS:
        queue: shortstr
            Specifies the name of the queue to bind.  If the queue
            name is empty, refers to the current queue for the
            channel, which is the last declared queue.
            RULE:
                If the client did not previously declare a queue,
                and the queue name in this method is empty, the
                server MUST raise a connection exception with
                reply code 530 (not allowed).
            RULE:
                If the queue does not exist the server MUST raise
                a channel exception with reply code 404 (not
                found).
        exchange: shortstr
            The name of the exchange to bind to.
            RULE:
                If the exchange does not exist the server MUST
                raise a channel exception with reply code 404 (not
                found).
        routing_key: shortstr
            message routing key
            Specifies the routing key for the binding.  The
            routing key is used for routing messages depending on
            the exchange configuration. Not all exchanges use a
            routing key - refer to the specific exchange
            documentation.  If the routing key is empty and the
            queue name is empty, the routing key will be the
            current queue for the channel, which is the last
            declared queue.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
        arguments: table
            arguments for binding
            A set of arguments for the binding.  The syntax and
            semantics of these arguments depends on the exchange
            class.
    """
    arguments = {} if arguments is None else arguments
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_shortstr(exchange)
    args.write_shortstr(routing_key)
    args.write_bit(nowait)
    args.write_table(arguments)
    self._send_method((50, 20), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (50, 21),  # Channel.queue_bind_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.queue_declare">
    <p>def <span class="ident">queue_declare</span>(</p><p>self, queue=&#39;&#39;, passive=False, durable=False, exclusive=False, auto_delete=True, nowait=False, arguments=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Declare queue, create if needed</p>
<p>This method creates or checks a queue.  When creating a new
queue the client can specify various properties that control
the durability of the queue and its contents, and the level of
sharing for the queue.</p>
<p>RULE:</p>
<pre><code>The server MUST create a default binding for a newly-
created queue to the default exchange, which is an
exchange of type 'direct'.
</code></pre>
<p>RULE:</p>
<pre><code>The server SHOULD support a minimum of 256 queues per
virtual host and ideally, impose no limit except as
defined by available resources.
</code></pre>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    RULE:

        The queue name MAY be empty, in which case the
        server MUST create a new queue with a unique
        generated name and return this to the client in
        the Declare-Ok method.

    RULE:

        Queue names starting with "amq." are reserved for
        predeclared and standardised server queues.  If
        the queue name starts with "amq." and the passive
        option is False, the server MUST raise a connection
        exception with reply code 403 (access refused).

passive: boolean

    do not create queue

    If set, the server will not create the queue.  The
    client can use this to check whether a queue exists
    without modifying the server state.

    RULE:

        If set, and the queue does not already exist, the
        server MUST respond with a reply code 404 (not
        found) and raise a channel exception.

durable: boolean

    request a durable queue

    If set when creating a new queue, the queue will be
    marked as durable.  Durable queues remain active when
    a server restarts. Non-durable queues (transient
    queues) are purged if/when a server restarts.  Note
    that durable queues do not necessarily hold persistent
    messages, although it does not make sense to send
    persistent messages to a transient queue.

    RULE:

        The server MUST recreate the durable queue after a
        restart.

    RULE:

        The server MUST support both durable and transient
        queues.

    RULE:

        The server MUST ignore the durable field if the
        queue already exists.

exclusive: boolean

    request an exclusive queue

    Exclusive queues may only be consumed from by the
    current connection. Setting the 'exclusive' flag
    always implies 'auto-delete'.

    RULE:

        The server MUST support both exclusive (private)
        and non-exclusive (shared) queues.

    RULE:

        The server MUST raise a channel exception if
        'exclusive' is specified and the queue already
        exists and is owned by a different connection.

auto_delete: boolean

    auto-delete queue when unused

    If set, the queue is deleted when all consumers have
    finished using it. Last consumer can be cancelled
    either explicitly or because its channel is closed. If
    there was no consumer ever on the queue, it won't be
    deleted.

    RULE:

        The server SHOULD allow for a reasonable delay
        between the point when it determines that a queue
        is not being used (or no longer used), and the
        point when it deletes the queue.  At the least it
        must allow a client to create a queue and then
        create a consumer to read from it, with a small
        but non-zero delay between these two actions.  The
        server should equally allow for clients that may
        be disconnected prematurely, and wish to re-
        consume from the same queue without losing
        messages.  We would recommend a configurable
        timeout, with a suitable default value being one
        minute.

    RULE:

        The server MUST ignore the auto-delete field if
        the queue already exists.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.

arguments: table

    arguments for declaration

    A set of arguments for the declaration. The syntax and
    semantics of these arguments depends on the server
    implementation.  This field is ignored if passive is
    True.
</code></pre>
<p>Returns a tuple containing 3 items:
    the name of the queue (essential for automatically-named queues)
    message count
    consumer count</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.queue_declare', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.queue_declare" class="source">
    <pre><code>def queue_declare(self, queue='', passive=False, durable=False,
                  exclusive=False, auto_delete=True, nowait=False,
                  arguments=None):
    """Declare queue, create if needed
    This method creates or checks a queue.  When creating a new
    queue the client can specify various properties that control
    the durability of the queue and its contents, and the level of
    sharing for the queue.
    RULE:
        The server MUST create a default binding for a newly-
        created queue to the default exchange, which is an
        exchange of type 'direct'.
    RULE:
        The server SHOULD support a minimum of 256 queues per
        virtual host and ideally, impose no limit except as
        defined by available resources.
    PARAMETERS:
        queue: shortstr
            RULE:
                The queue name MAY be empty, in which case the
                server MUST create a new queue with a unique
                generated name and return this to the client in
                the Declare-Ok method.
            RULE:
                Queue names starting with "amq." are reserved for
                predeclared and standardised server queues.  If
                the queue name starts with "amq." and the passive
                option is False, the server MUST raise a connection
                exception with reply code 403 (access refused).
        passive: boolean
            do not create queue
            If set, the server will not create the queue.  The
            client can use this to check whether a queue exists
            without modifying the server state.
            RULE:
                If set, and the queue does not already exist, the
                server MUST respond with a reply code 404 (not
                found) and raise a channel exception.
        durable: boolean
            request a durable queue
            If set when creating a new queue, the queue will be
            marked as durable.  Durable queues remain active when
            a server restarts. Non-durable queues (transient
            queues) are purged if/when a server restarts.  Note
            that durable queues do not necessarily hold persistent
            messages, although it does not make sense to send
            persistent messages to a transient queue.
            RULE:
                The server MUST recreate the durable queue after a
                restart.
            RULE:
                The server MUST support both durable and transient
                queues.
            RULE:
                The server MUST ignore the durable field if the
                queue already exists.
        exclusive: boolean
            request an exclusive queue
            Exclusive queues may only be consumed from by the
            current connection. Setting the 'exclusive' flag
            always implies 'auto-delete'.
            RULE:
                The server MUST support both exclusive (private)
                and non-exclusive (shared) queues.
            RULE:
                The server MUST raise a channel exception if
                'exclusive' is specified and the queue already
                exists and is owned by a different connection.
        auto_delete: boolean
            auto-delete queue when unused
            If set, the queue is deleted when all consumers have
            finished using it. Last consumer can be cancelled
            either explicitly or because its channel is closed. If
            there was no consumer ever on the queue, it won't be
            deleted.
            RULE:
                The server SHOULD allow for a reasonable delay
                between the point when it determines that a queue
                is not being used (or no longer used), and the
                point when it deletes the queue.  At the least it
                must allow a client to create a queue and then
                create a consumer to read from it, with a small
                but non-zero delay between these two actions.  The
                server should equally allow for clients that may
                be disconnected prematurely, and wish to re-
                consume from the same queue without losing
                messages.  We would recommend a configurable
                timeout, with a suitable default value being one
                minute.
            RULE:
                The server MUST ignore the auto-delete field if
                the queue already exists.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
        arguments: table
            arguments for declaration
            A set of arguments for the declaration. The syntax and
            semantics of these arguments depends on the server
            implementation.  This field is ignored if passive is
            True.
    Returns a tuple containing 3 items:
        the name of the queue (essential for automatically-named queues)
        message count
        consumer count
    """
    arguments = {} if arguments is None else arguments
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_bit(passive)
    args.write_bit(durable)
    args.write_bit(exclusive)
    args.write_bit(auto_delete)
    args.write_bit(nowait)
    args.write_table(arguments)
    self._send_method((50, 10), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (50, 11),  # Channel.queue_declare_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.queue_delete">
    <p>def <span class="ident">queue_delete</span>(</p><p>self, queue=&#39;&#39;, if_unused=False, if_empty=False, nowait=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete a queue</p>
<p>This method deletes a queue.  When a queue is deleted any
pending messages are sent to a dead-letter queue if this is
defined in the server configuration, and all consumers on the
queue are cancelled.</p>
<p>RULE:</p>
<pre><code>The server SHOULD use a dead-letter queue to hold messages
that were pending on a deleted queue, and MAY provide
facilities for a system administrator to move these
messages back to an active queue.
</code></pre>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    Specifies the name of the queue to delete. If the
    queue name is empty, refers to the current queue for
    the channel, which is the last declared queue.

    RULE:

        If the client did not previously declare a queue,
        and the queue name in this method is empty, the
        server MUST raise a connection exception with
        reply code 530 (not allowed).

    RULE:

        The queue must exist. Attempting to delete a non-
        existing queue causes a channel exception.

if_unused: boolean

    delete only if unused

    If set, the server will only delete the queue if it
    has no consumers. If the queue has consumers the
    server does does not delete it but raises a channel
    exception instead.

    RULE:

        The server MUST respect the if-unused flag when
        deleting a queue.

if_empty: boolean

    delete only if empty

    If set, the server will only delete the queue if it
    has no messages. If the queue is not empty the server
    raises a channel exception.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.queue_delete', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.queue_delete" class="source">
    <pre><code>def queue_delete(self, queue='',
                 if_unused=False, if_empty=False, nowait=False):
    """Delete a queue
    This method deletes a queue.  When a queue is deleted any
    pending messages are sent to a dead-letter queue if this is
    defined in the server configuration, and all consumers on the
    queue are cancelled.
    RULE:
        The server SHOULD use a dead-letter queue to hold messages
        that were pending on a deleted queue, and MAY provide
        facilities for a system administrator to move these
        messages back to an active queue.
    PARAMETERS:
        queue: shortstr
            Specifies the name of the queue to delete. If the
            queue name is empty, refers to the current queue for
            the channel, which is the last declared queue.
            RULE:
                If the client did not previously declare a queue,
                and the queue name in this method is empty, the
                server MUST raise a connection exception with
                reply code 530 (not allowed).
            RULE:
                The queue must exist. Attempting to delete a non-
                existing queue causes a channel exception.
        if_unused: boolean
            delete only if unused
            If set, the server will only delete the queue if it
            has no consumers. If the queue has consumers the
            server does does not delete it but raises a channel
            exception instead.
            RULE:
                The server MUST respect the if-unused flag when
                deleting a queue.
        if_empty: boolean
            delete only if empty
            If set, the server will only delete the queue if it
            has no messages. If the queue is not empty the server
            raises a channel exception.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
    """
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_bit(if_unused)
    args.write_bit(if_empty)
    args.write_bit(nowait)
    self._send_method((50, 40), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (50, 41),  # Channel.queue_delete_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.queue_purge">
    <p>def <span class="ident">queue_purge</span>(</p><p>self, queue=&#39;&#39;, nowait=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Purge a queue</p>
<p>This method removes all messages from a queue.  It does not
cancel consumers.  Purged messages are deleted without any
formal "undo" mechanism.</p>
<p>RULE:</p>
<pre><code>A call to purge MUST result in an empty queue.
</code></pre>
<p>RULE:</p>
<pre><code>On transacted channels the server MUST not purge messages
that have already been sent to a client but not yet
acknowledged.
</code></pre>
<p>RULE:</p>
<pre><code>The server MAY implement a purge queue or log that allows
system administrators to recover accidentally-purged
messages.  The server SHOULD NOT keep purged messages in
the same storage spaces as the live messages since the
volumes of purged messages may get very large.
</code></pre>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    Specifies the name of the queue to purge.  If the
    queue name is empty, refers to the current queue for
    the channel, which is the last declared queue.

    RULE:

        If the client did not previously declare a queue,
        and the queue name in this method is empty, the
        server MUST raise a connection exception with
        reply code 530 (not allowed).

    RULE:

        The queue must exist. Attempting to purge a non-
        existing queue causes a channel exception.

nowait: boolean

    do not send a reply method

    If set, the server will not respond to the method. The
    client should not wait for a reply method.  If the
    server could not complete the method it will raise a
    channel or connection exception.
</code></pre>
<p>if nowait is False, returns a message_count</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.queue_purge', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.queue_purge" class="source">
    <pre><code>def queue_purge(self, queue='', nowait=False):
    """Purge a queue
    This method removes all messages from a queue.  It does not
    cancel consumers.  Purged messages are deleted without any
    formal "undo" mechanism.
    RULE:
        A call to purge MUST result in an empty queue.
    RULE:
        On transacted channels the server MUST not purge messages
        that have already been sent to a client but not yet
        acknowledged.
    RULE:
        The server MAY implement a purge queue or log that allows
        system administrators to recover accidentally-purged
        messages.  The server SHOULD NOT keep purged messages in
        the same storage spaces as the live messages since the
        volumes of purged messages may get very large.
    PARAMETERS:
        queue: shortstr
            Specifies the name of the queue to purge.  If the
            queue name is empty, refers to the current queue for
            the channel, which is the last declared queue.
            RULE:
                If the client did not previously declare a queue,
                and the queue name in this method is empty, the
                server MUST raise a connection exception with
                reply code 530 (not allowed).
            RULE:
                The queue must exist. Attempting to purge a non-
                existing queue causes a channel exception.
        nowait: boolean
            do not send a reply method
            If set, the server will not respond to the method. The
            client should not wait for a reply method.  If the
            server could not complete the method it will raise a
            channel or connection exception.
    if nowait is False, returns a message_count
    """
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_bit(nowait)
    self._send_method((50, 30), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (50, 31),  # Channel.queue_purge_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.queue_unbind">
    <p>def <span class="ident">queue_unbind</span>(</p><p>self, queue, exchange, routing_key=&#39;&#39;, nowait=False, arguments=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Unbind a queue from an exchange</p>
<p>This method unbinds a queue from an exchange.</p>
<p>RULE:</p>
<pre><code>If a unbind fails, the server MUST raise a connection exception.
</code></pre>
<p>PARAMETERS:
    queue: shortstr</p>
<pre><code>    Specifies the name of the queue to unbind.

    RULE:

        The client MUST either specify a queue name or have
        previously declared a queue on the same channel

    RULE:

        The client MUST NOT attempt to unbind a queue that
        does not exist.

exchange: shortstr

    The name of the exchange to unbind from.

    RULE:

        The client MUST NOT attempt to unbind a queue from an
        exchange that does not exist.

    RULE:

        The server MUST accept a blank exchange name to mean
        the default exchange.

routing_key: shortstr

    routing key of binding

    Specifies the routing key of the binding to unbind.

arguments: table

    arguments of binding

    Specifies the arguments of the binding to unbind.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.queue_unbind', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.queue_unbind" class="source">
    <pre><code>def queue_unbind(self, queue, exchange, routing_key='',
                 nowait=False, arguments=None):
    """Unbind a queue from an exchange
    This method unbinds a queue from an exchange.
    RULE:
        If a unbind fails, the server MUST raise a connection exception.
    PARAMETERS:
        queue: shortstr
            Specifies the name of the queue to unbind.
            RULE:
                The client MUST either specify a queue name or have
                previously declared a queue on the same channel
            RULE:
                The client MUST NOT attempt to unbind a queue that
                does not exist.
        exchange: shortstr
            The name of the exchange to unbind from.
            RULE:
                The client MUST NOT attempt to unbind a queue from an
                exchange that does not exist.
            RULE:
                The server MUST accept a blank exchange name to mean
                the default exchange.
        routing_key: shortstr
            routing key of binding
            Specifies the routing key of the binding to unbind.
        arguments: table
            arguments of binding
            Specifies the arguments of the binding to unbind.
    """
    arguments = {} if arguments is None else arguments
    args = AMQPWriter()
    args.write_short(0)
    args.write_shortstr(queue)
    args.write_shortstr(exchange)
    args.write_shortstr(routing_key)
    args.write_table(arguments)
    self._send_method((50, 50), args)
    if not nowait:
        return self.wait(allowed_methods=[
            (50, 51),  # Channel.queue_unbind_ok
        ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.tx_commit">
    <p>def <span class="ident">tx_commit</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Commit the current transaction</p>
<p>This method commits all messages published and acknowledged in
the current transaction.  A new transaction starts immediately
after a commit.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.tx_commit', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.tx_commit" class="source">
    <pre><code>def tx_commit(self):
    """Commit the current transaction
    This method commits all messages published and acknowledged in
    the current transaction.  A new transaction starts immediately
    after a commit.
    """
    self._send_method((90, 20))
    return self.wait(allowed_methods=[
        (90, 21),  # Channel.tx_commit_ok
    ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.tx_rollback">
    <p>def <span class="ident">tx_rollback</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Abandon the current transaction</p>
<p>This method abandons all messages published and acknowledged
in the current transaction.  A new transaction starts
immediately after a rollback.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.tx_rollback', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.tx_rollback" class="source">
    <pre><code>def tx_rollback(self):
    """Abandon the current transaction
    This method abandons all messages published and acknowledged
    in the current transaction.  A new transaction starts
    immediately after a rollback.
    """
    self._send_method((90, 30))
    return self.wait(allowed_methods=[
        (90, 31),  # Channel.tx_rollback_ok
    ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.tx_select">
    <p>def <span class="ident">tx_select</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Select standard transaction mode</p>
<p>This method sets the channel to use standard transactions.
The client must use this method at least once on a channel
before using the Commit or Rollback methods.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.tx_select', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.tx_select" class="source">
    <pre><code>def tx_select(self):
    """Select standard transaction mode
    This method sets the channel to use standard transactions.
    The client must use this method at least once on a channel
    before using the Commit or Rollback methods.
    """
    self._send_method((90, 10))
    return self.wait(allowed_methods=[
        (90, 11),  # Channel.tx_select_ok
    ])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Channel.wait">
    <p>def <span class="ident">wait</span>(</p><p>self, allowed_methods=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for a method that matches our allowed_methods parameter (the
default value of None means match any method), and dispatch to it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Channel.wait', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Channel.wait" class="source">
    <pre><code>def wait(self, allowed_methods=None):
    """Wait for a method that matches our allowed_methods parameter (the
    default value of None means match any method), and dispatch to it."""
    method_sig, args, content = self.connection._wait_method(
        self.channel_id, allowed_methods)
    return self.dispatch_method(method_sig, args, content)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.active" class="name">var <span class="ident">active</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.auto_encode_decode" class="name">var <span class="ident">auto_encode_decode</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.callbacks" class="name">var <span class="ident">callbacks</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.cancel_callbacks" class="name">var <span class="ident">cancel_callbacks</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.events" class="name">var <span class="ident">events</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.is_open" class="name">var <span class="ident">is_open</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.no_ack_consumers" class="name">var <span class="ident">no_ack_consumers</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Channel.returned_messages" class="name">var <span class="ident">returned_messages</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ChannelError" class="name">class <span class="ident">ChannelError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ChannelError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ChannelError" class="source">
    <pre><code>class ChannelError(AMQPError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ChannelError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ChannelError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ChannelError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ChannelError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ChannelError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ChannelError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ChannelNotOpen" class="name">class <span class="ident">ChannelNotOpen</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ChannelNotOpen', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ChannelNotOpen" class="source">
    <pre><code>class ChannelNotOpen(IrrecoverableConnectionError):
    code = 504
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ChannelNotOpen">ChannelNotOpen</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ChannelNotOpen.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ChannelNotOpen.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ChannelNotOpen.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ChannelNotOpen.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ChannelNotOpen.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ChannelNotOpen.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.Connection" class="name">class <span class="ident">Connection</span></p>
      
  
    <div class="desc"><p>The connection class provides methods for a client to establish a
network connection to a server, and for both peers to operate the
connection thereafter.</p>
<p>GRAMMAR::</p>
<pre><code>connection          = open-connection *use-connection close-connection
open-connection     = C:protocol-header
                      S:START C:START-OK
                      *challenge
                      S:TUNE C:TUNE-OK
                      C:OPEN S:OPEN-OK
challenge           = S:SECURE C:SECURE-OK
use-connection      = *channel
close-connection    = C:CLOSE S:CLOSE-OK
                    / S:CLOSE C:CLOSE-OK
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection" class="source">
    <pre><code>class Connection(AbstractChannel):
    """The connection class provides methods for a client to establish a
    network connection to a server, and for both peers to operate the
    connection thereafter.

    GRAMMAR::

        connection          = open-connection *use-connection close-connection
        open-connection     = C:protocol-header
                              S:START C:START-OK
                              *challenge
                              S:TUNE C:TUNE-OK
                              C:OPEN S:OPEN-OK
        challenge           = S:SECURE C:SECURE-OK
        use-connection      = *channel
        close-connection    = C:CLOSE S:CLOSE-OK
                            / S:CLOSE C:CLOSE-OK

    """
    Channel = Channel

    #: Final heartbeat interval value (in float seconds) after negotiation
    heartbeat = None

    #: Original heartbeat interval value proposed by client.
    client_heartbeat = None

    #: Original heartbeat interval proposed by server.
    server_heartbeat = None

    #: Time of last heartbeat sent (in monotonic time, if available).
    last_heartbeat_sent = 0

    #: Time of last heartbeat received (in monotonic time, if available).
    last_heartbeat_received = 0

    #: Number of bytes sent to socket at the last heartbeat check.
    prev_sent = None

    #: Number of bytes received from socket at the last heartbeat check.
    prev_recv = None

    def __init__(self, host='localhost', userid='guest', password='guest',
                 login_method='AMQPLAIN', login_response=None,
                 virtual_host='/', locale='en_US', client_properties=None,
                 ssl=False, connect_timeout=None, operation_timeout=None,
                 channel_max=None, frame_max=None, heartbeat=0,
                 on_blocked=None, on_unblocked=None, confirm_publish=False,
                 **kwargs):
        """Create a connection to the specified host, which should be
        a 'host[:port]', such as 'localhost', or '1.2.3.4:5672'
        (defaults to 'localhost', if a port is not specified then
        5672 is used)

        If login_response is not specified, one is built up for you from
        userid and password if they are present.

        The 'ssl' parameter may be simply True/False, or for Python >= 2.6
        a dictionary of options to pass to ssl.wrap_socket() such as
        requiring certain certificates or an SSLContext (>= 2.7.9) to use.

        """
        channel_max = channel_max or 65535
        frame_max = frame_max or 131072
        if (login_response is None) \
                and (userid is not None) \
                and (password is not None):
            login_response = AMQPWriter()
            login_response.write_table({'LOGIN': userid, 'PASSWORD': password})
            # Skip the length at the beginning
            login_response = login_response.getvalue()[4:]

        d = dict(LIBRARY_PROPERTIES, **client_properties or {})
        self._method_override = {(60, 50): self._dispatch_basic_return}

        self.channels = {}
        # The connection object itself is treated as channel 0
        super(Connection, self).__init__(self, 0)

        self.transport = None

        # Properties set in the Tune method
        self.channel_max = channel_max
        self.frame_max = frame_max
        self.client_heartbeat = heartbeat

        self.confirm_publish = confirm_publish

        # Callbacks
        self.on_blocked = on_blocked
        self.on_unblocked = on_unblocked

        self._avail_channel_ids = array('H', range(self.channel_max, 0, -1))

        # Properties set in the Start method
        self.version_major = 0
        self.version_minor = 0
        self.server_properties = {}
        self.mechanisms = []
        self.locales = []

        # Let the transport.py module setup the actual
        # socket connection to the broker.
        #
        self.transport = self.Transport(
            host, connect_timeout, operation_timeout, ssl
        )

        self.method_reader = MethodReader(self.transport)
        self.method_writer = MethodWriter(self.transport, self.frame_max)

        self.wait(allowed_methods=[
            (10, 10),  # start
        ])

        self._x_start_ok(d, login_method, login_response, locale)

        self._wait_tune_ok = True
        while self._wait_tune_ok:
            self.wait(allowed_methods=[
                (10, 20),  # secure
                (10, 30),  # tune
            ])

        return self._x_open(virtual_host)

    def Transport(self, host, connect_timeout, operation_timeout, ssl=False):
        return create_transport(host, connect_timeout, operation_timeout, ssl)

    @property
    def connected(self):
        return self.transport and self.transport.connected

    def _do_close(self):
        try:
            self.transport.close()

            temp_list = [x for x in values(self.channels) if x is not self]
            for ch in temp_list:
                ch._do_close()
        except socket.error:
            pass  # connection already closed on the other end
        finally:
            self.transport = self.connection = self.channels = None

    def _get_free_channel_id(self):
        try:
            return self._avail_channel_ids.pop()
        except IndexError:
            raise ResourceError(
                'No free channel ids, current={0}, channel_max={1}'.format(
                    len(self.channels), self.channel_max), (20, 10))

    def _claim_channel_id(self, channel_id):
        try:
            return self._avail_channel_ids.remove(channel_id)
        except ValueError:
            raise ConnectionError(
                'Channel %r already open' % (channel_id, ))

    def _wait_method(self, channel_id, allowed_methods):
        """Wait for a method from the server destined for
        a particular channel."""
        #
        # Check the channel's deferred methods
        #
        method_queue = self.channels[channel_id].method_queue

        for queued_method in method_queue:
            method_sig = queued_method[0]
            if (allowed_methods is None) \
                    or (method_sig in allowed_methods) \
                    or (method_sig == (20, 40)):
                method_queue.remove(queued_method)
                return queued_method

        #
        # Nothing queued, need to wait for a method from the peer
        #
        while 1:
            channel, method_sig, args, content = \
                self.method_reader.read_method()

            if channel == channel_id and (
                    allowed_methods is None or
                    method_sig in allowed_methods or
                    method_sig == (20, 40)):
                return method_sig, args, content

            #
            # Certain methods like basic_return should be dispatched
            # immediately rather than being queued, even if they're not
            # one of the 'allowed_methods' we're looking for.
            #
            if channel and method_sig in self.Channel._IMMEDIATE_METHODS:
                self.channels[channel].dispatch_method(
                    method_sig, args, content,
                )
                continue

            #
            # Not the channel and/or method we were looking for.  Queue
            # this method for later
            #
            self.channels[channel].method_queue.append(
                (method_sig, args, content),
            )

            #
            # If we just queued up a method for channel 0 (the Connection
            # itself) it's probably a close method in reaction to some
            # error, so deal with it right away.
            #
            if not channel:
                self.wait()

    def channel(self, channel_id=None, auto_encode_decode=True):
        """Fetch a Channel object identified by the numeric channel_id, or
        create that object if it doesn't already exist. See Channel for meaning
        of auto_encode_decode. If the channel already exists, the auto_* flag
        will not be updated."""
        try:
            return self.channels[channel_id]
        except KeyError:
            return self.Channel(self, channel_id,
                                auto_encode_decode=auto_encode_decode)

    def is_alive(self):
        if HAS_MSG_PEEK:
            sock = self.sock
            prev = sock.gettimeout()
            sock.settimeout(0.0001)
            try:
                sock.recv(1, socket.MSG_PEEK)
            except socket.timeout:
                pass
            except socket.error:
                return False
            finally:
                sock.settimeout(prev)
        return True

    def drain_events(self, timeout=None):
        """Wait for an event on a channel."""
        chanmap = self.channels
        chanid, method_sig, args, content = self._wait_multiple(
            chanmap, None, timeout=timeout,
        )

        channel = chanmap[chanid]

        if (content and
                channel.auto_encode_decode and
                hasattr(content, 'content_encoding')):
            try:
                content.body = content.body.decode(content.content_encoding)
            except Exception:
                pass

        amqp_method = (self._method_override.get(method_sig) or
                       channel._METHOD_MAP.get(method_sig, None))

        if amqp_method is None:
            raise AMQPNotImplementedError(
                'Unknown AMQP method {0!r}'.format(method_sig))

        if content is None:
            return amqp_method(channel, args)
        else:
            return amqp_method(channel, args, content)

    def read_timeout(self, timeout=None):
        if timeout is None:
            return self.method_reader.read_method()
        sock = self.sock
        prev = sock.gettimeout()
        if prev != timeout:
            sock.settimeout(timeout)
        try:
            try:
                return self.method_reader.read_method()
            except SSLError as exc:
                # http://bugs.python.org/issue10272
                if 'timed out' in str(exc):
                    raise socket.timeout()
                # Non-blocking SSL sockets can throw SSLError
                if 'The operation did not complete' in str(exc):
                    raise socket.timeout()
                raise
        finally:
            if prev != timeout:
                sock.settimeout(prev)

    def _wait_multiple(self, channels, allowed_methods, timeout=None):
        for channel_id, channel in items(channels):
            method_queue = channel.method_queue
            for queued_method in method_queue:
                method_sig = queued_method[0]
                if (allowed_methods is None or
                        method_sig in allowed_methods or
                        method_sig == (20, 40)):
                    method_queue.remove(queued_method)
                    method_sig, args, content = queued_method
                    return channel_id, method_sig, args, content

        # Nothing queued, need to wait for a method from the peer
        read_timeout = self.read_timeout
        wait = self.wait
        while 1:
            channel, method_sig, args, content = read_timeout(timeout)

            if channel in channels and (
                    allowed_methods is None or
                    method_sig in allowed_methods or
                    method_sig == (20, 40)):
                return channel, method_sig, args, content

            # Not the channel and/or method we were looking for. Queue
            # this method for later
            channels[channel].method_queue.append((method_sig, args, content))

            #
            # If we just queued up a method for channel 0 (the Connection
            # itself) it's probably a close method in reaction to some
            # error, so deal with it right away.
            #
            if channel == 0:
                wait()

    def _dispatch_basic_return(self, channel, args, msg):
        reply_code = args.read_short()
        reply_text = args.read_shortstr()
        exchange = args.read_shortstr()
        routing_key = args.read_shortstr()

        exc = error_for_code(reply_code, reply_text, (50, 60), ChannelError)
        handlers = channel.events.get('basic_return')
        if not handlers:
            raise exc
        for callback in handlers:
            callback(exc, exchange, routing_key, msg)

    def close(self, reply_code=0, reply_text='', method_sig=(0, 0)):
        """Request a connection close

        This method indicates that the sender wants to close the
        connection. This may be due to internal conditions (e.g. a
        forced shut-down) or due to an error handling a specific
        method, i.e. an exception.  When a close is due to an
        exception, the sender provides the class and method id of the
        method which caused the exception.

        RULE:

            After sending this method any received method except the
            Close-OK method MUST be discarded.

        RULE:

            The peer sending this method MAY use a counter or timeout
            to detect failure of the other peer to respond correctly
            with the Close-OK method.

        RULE:

            When a server receives the Close method from a client it
            MUST delete all server-side resources associated with the
            client's context.  A client CANNOT reconnect to a context
            after sending or receiving a Close method.

        PARAMETERS:
            reply_code: short

                The reply code. The AMQ reply codes are defined in AMQ
                RFC 011.

            reply_text: shortstr

                The localised reply text.  This text can be logged as an
                aid to resolving issues.

            class_id: short

                failing method class

                When the close is provoked by a method exception, this
                is the class of the method.

            method_id: short

                failing method ID

                When the close is provoked by a method exception, this
                is the ID of the method.

        """
        if self.transport is None:
            # already closed
            return

        args = AMQPWriter()
        args.write_short(reply_code)
        args.write_shortstr(reply_text)
        args.write_short(method_sig[0])  # class_id
        args.write_short(method_sig[1])  # method_id
        try:
            self._send_method((10, 50), args)
            return self.wait(allowed_methods=[
                (10, 50),  # Connection.close
                (10, 51),  # Connection.close_ok
            ])
        except (socket.timeout, socket.error) as e:
            # no point in waiting anymore
            if isinstance(e, socket.timeout):
                try:
                    self.sock.settimeout(0.1)
                except:
                    pass
            # lack of communication should not prevent tidy-up
            self._do_close()

    def _close(self, args):
        """Request a connection close

        This method indicates that the sender wants to close the
        connection. This may be due to internal conditions (e.g. a
        forced shut-down) or due to an error handling a specific
        method, i.e. an exception.  When a close is due to an
        exception, the sender provides the class and method id of the
        method which caused the exception.

        RULE:

            After sending this method any received method except the
            Close-OK method MUST be discarded.

        RULE:

            The peer sending this method MAY use a counter or timeout
            to detect failure of the other peer to respond correctly
            with the Close-OK method.

        RULE:

            When a server receives the Close method from a client it
            MUST delete all server-side resources associated with the
            client's context.  A client CANNOT reconnect to a context
            after sending or receiving a Close method.

        PARAMETERS:
            reply_code: short

                The reply code. The AMQ reply codes are defined in AMQ
                RFC 011.

            reply_text: shortstr

                The localised reply text.  This text can be logged as an
                aid to resolving issues.

            class_id: short

                failing method class

                When the close is provoked by a method exception, this
                is the class of the method.

            method_id: short

                failing method ID

                When the close is provoked by a method exception, this
                is the ID of the method.

        """
        reply_code = args.read_short()
        reply_text = args.read_shortstr()
        class_id = args.read_short()
        method_id = args.read_short()

        self._x_close_ok()

        raise error_for_code(reply_code, reply_text,
                             (class_id, method_id), ConnectionError)

    def _blocked(self, args):
        """RabbitMQ Extension."""
        reason = args.read_shortstr()
        if self.on_blocked:
            return self.on_blocked(reason)

    def _unblocked(self, *args):
        if self.on_unblocked:
            return self.on_unblocked()

    def _x_close_ok(self):
        """Confirm a connection close

        This method confirms a Connection.Close method and tells the
        recipient that it is safe to release resources for the
        connection and close the socket.

        RULE:

            A peer that detects a socket closure without having
            received a Close-Ok handshake method SHOULD log the error.

        """
        self._send_method((10, 51))
        self._do_close()

    def _close_ok(self, args):
        """Confirm a connection close

        This method confirms a Connection.Close method and tells the
        recipient that it is safe to release resources for the
        connection and close the socket.

        RULE:

            A peer that detects a socket closure without having
            received a Close-Ok handshake method SHOULD log the error.

        """
        self._do_close()

    def _x_open(self, virtual_host, capabilities=''):
        """Open connection to virtual host

        This method opens a connection to a virtual host, which is a
        collection of resources, and acts to separate multiple
        application domains within a server.

        RULE:

            The client MUST open the context before doing any work on
            the connection.

        PARAMETERS:
            virtual_host: shortstr

                virtual host name

                The name of the virtual host to work with.

                RULE:

                    If the server supports multiple virtual hosts, it
                    MUST enforce a full separation of exchanges,
                    queues, and all associated entities per virtual
                    host. An application, connected to a specific
                    virtual host, MUST NOT be able to access resources
                    of another virtual host.

                RULE:

                    The server SHOULD verify that the client has
                    permission to access the specified virtual host.

                RULE:

                    The server MAY configure arbitrary limits per
                    virtual host, such as the number of each type of
                    entity that may be used, per connection and/or in
                    total.

            capabilities: shortstr

                required capabilities

                The client may specify a number of capability names,
                delimited by spaces.  The server can use this string
                to how to process the client's connection request.

        """
        args = AMQPWriter()
        args.write_shortstr(virtual_host)
        args.write_shortstr(capabilities)
        args.write_bit(False)
        self._send_method((10, 40), args)
        return self.wait(allowed_methods=[
            (10, 41),    # Connection.open_ok
        ])

    def _open_ok(self, args):
        """Signal that the connection is ready

        This method signals to the client that the connection is ready
        for use.

        PARAMETERS:
            known_hosts: shortstr (deprecated)

        """
        AMQP_LOGGER.debug('Open OK!')

    def _secure(self, args):
        """Security mechanism challenge

        The SASL protocol works by exchanging challenges and responses
        until both peers have received sufficient information to
        authenticate each other.  This method challenges the client to
        provide more information.

        PARAMETERS:
            challenge: longstr

                security challenge data

                Challenge information, a block of opaque binary data
                passed to the security mechanism.

        """
        challenge = args.read_longstr()  # noqa

    def _x_secure_ok(self, response):
        """Security mechanism response

        This method attempts to authenticate, passing a block of SASL
        data for the security mechanism at the server side.

        PARAMETERS:
            response: longstr

                security response data

                A block of opaque data passed to the security
                mechanism.  The contents of this data are defined by
                the SASL security mechanism.

        """
        args = AMQPWriter()
        args.write_longstr(response)
        self._send_method((10, 21), args)

    def _start(self, args):
        """Start connection negotiation

        This method starts the connection negotiation process by
        telling the client the protocol version that the server
        proposes, along with a list of security mechanisms which the
        client can use for authentication.

        RULE:

            If the client cannot handle the protocol version suggested
            by the server it MUST close the socket connection.

        RULE:

            The server MUST provide a protocol version that is lower
            than or equal to that requested by the client in the
            protocol header. If the server cannot support the
            specified protocol it MUST NOT send this method, but MUST
            close the socket connection.

        PARAMETERS:
            version_major: octet

                protocol major version

                The protocol major version that the server agrees to
                use, which cannot be higher than the client's major
                version.

            version_minor: octet

                protocol major version

                The protocol minor version that the server agrees to
                use, which cannot be higher than the client's minor
                version.

            server_properties: table

                server properties

            mechanisms: longstr

                available security mechanisms

                A list of the security mechanisms that the server
                supports, delimited by spaces.  Currently ASL supports
                these mechanisms: PLAIN.

            locales: longstr

                available message locales

                A list of the message locales that the server
                supports, delimited by spaces.  The locale defines the
                language in which the server will send reply texts.

                RULE:

                    All servers MUST support at least the en_US
                    locale.

        """
        self.version_major = args.read_octet()
        self.version_minor = args.read_octet()
        self.server_properties = args.read_table()
        self.mechanisms = args.read_longstr().split(' ')
        self.locales = args.read_longstr().split(' ')

        AMQP_LOGGER.debug(
            START_DEBUG_FMT,
            self.version_major, self.version_minor,
            self.server_properties, self.mechanisms, self.locales,
        )

    def _x_start_ok(self, client_properties, mechanism, response, locale):
        """Select security mechanism and locale

        This method selects a SASL security mechanism. ASL uses SASL
        (RFC2222) to negotiate authentication and encryption.

        PARAMETERS:
            client_properties: table

                client properties

            mechanism: shortstr

                selected security mechanism

                A single security mechanisms selected by the client,
                which must be one of those specified by the server.

                RULE:

                    The client SHOULD authenticate using the highest-
                    level security profile it can handle from the list
                    provided by the server.

                RULE:

                    The mechanism field MUST contain one of the
                    security mechanisms proposed by the server in the
                    Start method. If it doesn't, the server MUST close
                    the socket.

            response: longstr

                security response data

                A block of opaque data passed to the security
                mechanism. The contents of this data are defined by
                the SASL security mechanism.  For the PLAIN security
                mechanism this is defined as a field table holding two
                fields, LOGIN and PASSWORD.

            locale: shortstr

                selected message locale

                A single message local selected by the client, which
                must be one of those specified by the server.

        """
        if self.server_capabilities.get('consumer_cancel_notify'):
            if 'capabilities' not in client_properties:
                client_properties['capabilities'] = {}
            client_properties['capabilities']['consumer_cancel_notify'] = True
        if self.server_capabilities.get('connection.blocked'):
            if 'capabilities' not in client_properties:
                client_properties['capabilities'] = {}
            client_properties['capabilities']['connection.blocked'] = True
        args = AMQPWriter()
        args.write_table(client_properties)
        args.write_shortstr(mechanism)
        args.write_longstr(response)
        args.write_shortstr(locale)
        self._send_method((10, 11), args)

    def _tune(self, args):
        """Propose connection tuning parameters

        This method proposes a set of connection configuration values
        to the client.  The client can accept and/or adjust these.

        PARAMETERS:
            channel_max: short

                proposed maximum channels

                The maximum total number of channels that the server
                allows per connection. Zero means that the server does
                not impose a fixed limit, but the number of allowed
                channels may be limited by available server resources.

            frame_max: long

                proposed maximum frame size

                The largest frame size that the server proposes for
                the connection. The client can negotiate a lower
                value.  Zero means that the server does not impose any
                specific limit but may reject very large frames if it
                cannot allocate resources for them.

                RULE:

                    Until the frame-max has been negotiated, both
                    peers MUST accept frames of up to 4096 octets
                    large. The minimum non-zero value for the frame-
                    max field is 4096.

            heartbeat: short

                desired heartbeat delay

                The delay, in seconds, of the connection heartbeat
                that the server wants.  Zero means the server does not
                want a heartbeat.

        """
        client_heartbeat = self.client_heartbeat or 0
        self.channel_max = args.read_short() or self.channel_max
        self.frame_max = args.read_long() or self.frame_max
        self.method_writer.frame_max = self.frame_max
        self.server_heartbeat = args.read_short() or 0

        # negotiate the heartbeat interval to the smaller of the
        # specified values
        if self.server_heartbeat == 0 or client_heartbeat == 0:
            self.heartbeat = max(self.server_heartbeat, client_heartbeat)
        else:
            self.heartbeat = min(self.server_heartbeat, client_heartbeat)

        # Ignore server heartbeat if client_heartbeat is disabled
        if not self.client_heartbeat:
            self.heartbeat = 0

        self._x_tune_ok(self.channel_max, self.frame_max, self.heartbeat)

    def send_heartbeat(self):
        self.transport.write_frame(8, 0, bytes())

    def heartbeat_tick(self, rate=2):
        """Send heartbeat packets, if necessary, and fail if none have been
        received recently.  This should be called frequently, on the order of
        once per second.

        :keyword rate: Ignored
        """
        if not self.heartbeat:
            return

        # treat actual data exchange in either direction as a heartbeat
        sent_now = self.method_writer.bytes_sent
        recv_now = self.method_reader.bytes_recv
        if self.prev_sent is None or self.prev_sent != sent_now:
            self.last_heartbeat_sent = monotonic()
        if self.prev_recv is None or self.prev_recv != recv_now:
            self.last_heartbeat_received = monotonic()
        self.prev_sent, self.prev_recv = sent_now, recv_now

        # send a heartbeat if it's time to do so
        if monotonic() > self.last_heartbeat_sent + self.heartbeat:
            self.send_heartbeat()
            self.last_heartbeat_sent = monotonic()

        # if we've missed two intervals' heartbeats, fail; this gives the
        # server enough time to send heartbeats a little late
        if (self.last_heartbeat_received and
                self.last_heartbeat_received + 2 *
                self.heartbeat < monotonic()):
            raise ConnectionForced('Too many heartbeats missed')

    def _x_tune_ok(self, channel_max, frame_max, heartbeat):
        """Negotiate connection tuning parameters

        This method sends the client's connection tuning parameters to
        the server. Certain fields are negotiated, others provide
        capability information.

        PARAMETERS:
            channel_max: short

                negotiated maximum channels

                The maximum total number of channels that the client
                will use per connection.  May not be higher than the
                value specified by the server.

                RULE:

                    The server MAY ignore the channel-max value or MAY
                    use it for tuning its resource allocation.

            frame_max: long

                negotiated maximum frame size

                The largest frame size that the client and server will
                use for the connection.  Zero means that the client
                does not impose any specific limit but may reject very
                large frames if it cannot allocate resources for them.
                Note that the frame-max limit applies principally to
                content frames, where large contents can be broken
                into frames of arbitrary size.

                RULE:

                    Until the frame-max has been negotiated, both
                    peers must accept frames of up to 4096 octets
                    large. The minimum non-zero value for the frame-
                    max field is 4096.

            heartbeat: short

                desired heartbeat delay

                The delay, in seconds, of the connection heartbeat
                that the client wants. Zero means the client does not
                want a heartbeat.

        """
        args = AMQPWriter()
        args.write_short(channel_max)
        args.write_long(frame_max)
        args.write_short(heartbeat or 0)
        self._send_method((10, 31), args)
        self._wait_tune_ok = False

    @property
    def sock(self):
        return self.transport.sock

    @property
    def server_capabilities(self):
        return self.server_properties.get('capabilities') or {}

    _METHOD_MAP = {
        (10, 10): _start,
        (10, 20): _secure,
        (10, 30): _tune,
        (10, 41): _open_ok,
        (10, 50): _close,
        (10, 51): _close_ok,
        (10, 60): _blocked,
        (10, 61): _unblocked,
    }

    _IMMEDIATE_METHODS = []
    connection_errors = (
        ConnectionError,
        socket.error,
        IOError,
        OSError,
    )
    channel_errors = (ChannelError, )
    recoverable_connection_errors = (
        RecoverableConnectionError,
        socket.error,
        IOError,
        OSError,
    )
    recoverable_channel_errors = (
        RecoverableChannelError,
    )
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.Connection">Connection</a></li>
          <li>IoticAgent.third.amqp.abstract_channel.AbstractChannel</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.Channel" class="name">var <span class="ident">Channel</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.channel_errors" class="name">var <span class="ident">channel_errors</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.client_heartbeat" class="name">var <span class="ident">client_heartbeat</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.connection_errors" class="name">var <span class="ident">connection_errors</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.heartbeat" class="name">var <span class="ident">heartbeat</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.last_heartbeat_received" class="name">var <span class="ident">last_heartbeat_received</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.last_heartbeat_sent" class="name">var <span class="ident">last_heartbeat_sent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.prev_recv" class="name">var <span class="ident">prev_recv</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.prev_sent" class="name">var <span class="ident">prev_sent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.recoverable_channel_errors" class="name">var <span class="ident">recoverable_channel_errors</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.recoverable_connection_errors" class="name">var <span class="ident">recoverable_connection_errors</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.server_heartbeat" class="name">var <span class="ident">server_heartbeat</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, host=&#39;localhost&#39;, userid=&#39;guest&#39;, password=&#39;guest&#39;, login_method=&#39;AMQPLAIN&#39;, login_response=None, virtual_host=&#39;/&#39;, locale=&#39;en_US&#39;, client_properties=None, ssl=False, connect_timeout=None, operation_timeout=None, channel_max=None, frame_max=None, heartbeat=0, on_blocked=None, on_unblocked=None, confirm_publish=False, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a connection to the specified host, which should be
a 'host[:port]', such as 'localhost', or '1.2.3.4:5672'
(defaults to 'localhost', if a port is not specified then
5672 is used)</p>
<p>If login_response is not specified, one is built up for you from
userid and password if they are present.</p>
<p>The 'ssl' parameter may be simply True/False, or for Python &gt;= 2.6
a dictionary of options to pass to ssl.wrap_socket() such as
requiring certain certificates or an SSLContext (&gt;= 2.7.9) to use.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.__init__" class="source">
    <pre><code>def __init__(self, host='localhost', userid='guest', password='guest',
             login_method='AMQPLAIN', login_response=None,
             virtual_host='/', locale='en_US', client_properties=None,
             ssl=False, connect_timeout=None, operation_timeout=None,
             channel_max=None, frame_max=None, heartbeat=0,
             on_blocked=None, on_unblocked=None, confirm_publish=False,
             **kwargs):
    """Create a connection to the specified host, which should be
    a 'host[:port]', such as 'localhost', or '1.2.3.4:5672'
    (defaults to 'localhost', if a port is not specified then
    5672 is used)
    If login_response is not specified, one is built up for you from
    userid and password if they are present.
    The 'ssl' parameter may be simply True/False, or for Python >= 2.6
    a dictionary of options to pass to ssl.wrap_socket() such as
    requiring certain certificates or an SSLContext (>= 2.7.9) to use.
    """
    channel_max = channel_max or 65535
    frame_max = frame_max or 131072
    if (login_response is None) \
            and (userid is not None) \
            and (password is not None):
        login_response = AMQPWriter()
        login_response.write_table({'LOGIN': userid, 'PASSWORD': password})
        # Skip the length at the beginning
        login_response = login_response.getvalue()[4:]
    d = dict(LIBRARY_PROPERTIES, **client_properties or {})
    self._method_override = {(60, 50): self._dispatch_basic_return}
    self.channels = {}
    # The connection object itself is treated as channel 0
    super(Connection, self).__init__(self, 0)
    self.transport = None
    # Properties set in the Tune method
    self.channel_max = channel_max
    self.frame_max = frame_max
    self.client_heartbeat = heartbeat
    self.confirm_publish = confirm_publish
    # Callbacks
    self.on_blocked = on_blocked
    self.on_unblocked = on_unblocked
    self._avail_channel_ids = array('H', range(self.channel_max, 0, -1))
    # Properties set in the Start method
    self.version_major = 0
    self.version_minor = 0
    self.server_properties = {}
    self.mechanisms = []
    self.locales = []
    # Let the transport.py module setup the actual
    # socket connection to the broker.
    #
    self.transport = self.Transport(
        host, connect_timeout, operation_timeout, ssl
    )
    self.method_reader = MethodReader(self.transport)
    self.method_writer = MethodWriter(self.transport, self.frame_max)
    self.wait(allowed_methods=[
        (10, 10),  # start
    ])
    self._x_start_ok(d, login_method, login_response, locale)
    self._wait_tune_ok = True
    while self._wait_tune_ok:
        self.wait(allowed_methods=[
            (10, 20),  # secure
            (10, 30),  # tune
        ])
    return self._x_open(virtual_host)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.Transport">
    <p>def <span class="ident">Transport</span>(</p><p>self, host, connect_timeout, operation_timeout, ssl=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.Transport', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.Transport" class="source">
    <pre><code>def Transport(self, host, connect_timeout, operation_timeout, ssl=False):
    return create_transport(host, connect_timeout, operation_timeout, ssl)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.channel">
    <p>def <span class="ident">channel</span>(</p><p>self, channel_id=None, auto_encode_decode=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Fetch a Channel object identified by the numeric channel_id, or
create that object if it doesn't already exist. See Channel for meaning
of auto_encode_decode. If the channel already exists, the auto_* flag
will not be updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.channel', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.channel" class="source">
    <pre><code>def channel(self, channel_id=None, auto_encode_decode=True):
    """Fetch a Channel object identified by the numeric channel_id, or
    create that object if it doesn't already exist. See Channel for meaning
    of auto_encode_decode. If the channel already exists, the auto_* flag
    will not be updated."""
    try:
        return self.channels[channel_id]
    except KeyError:
        return self.Channel(self, channel_id,
                            auto_encode_decode=auto_encode_decode)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.close">
    <p>def <span class="ident">close</span>(</p><p>self, reply_code=0, reply_text=&#39;&#39;, method_sig=(0, 0))</p>
    </div>
    

    
  
    <div class="desc"><p>Request a connection close</p>
<p>This method indicates that the sender wants to close the
connection. This may be due to internal conditions (e.g. a
forced shut-down) or due to an error handling a specific
method, i.e. an exception.  When a close is due to an
exception, the sender provides the class and method id of the
method which caused the exception.</p>
<p>RULE:</p>
<pre><code>After sending this method any received method except the
Close-OK method MUST be discarded.
</code></pre>
<p>RULE:</p>
<pre><code>The peer sending this method MAY use a counter or timeout
to detect failure of the other peer to respond correctly
with the Close-OK method.
</code></pre>
<p>RULE:</p>
<pre><code>When a server receives the Close method from a client it
MUST delete all server-side resources associated with the
client's context.  A client CANNOT reconnect to a context
after sending or receiving a Close method.
</code></pre>
<p>PARAMETERS:
    reply_code: short</p>
<pre><code>    The reply code. The AMQ reply codes are defined in AMQ
    RFC 011.

reply_text: shortstr

    The localised reply text.  This text can be logged as an
    aid to resolving issues.

class_id: short

    failing method class

    When the close is provoked by a method exception, this
    is the class of the method.

method_id: short

    failing method ID

    When the close is provoked by a method exception, this
    is the ID of the method.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.close', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.close" class="source">
    <pre><code>def close(self, reply_code=0, reply_text='', method_sig=(0, 0)):
    """Request a connection close
    This method indicates that the sender wants to close the
    connection. This may be due to internal conditions (e.g. a
    forced shut-down) or due to an error handling a specific
    method, i.e. an exception.  When a close is due to an
    exception, the sender provides the class and method id of the
    method which caused the exception.
    RULE:
        After sending this method any received method except the
        Close-OK method MUST be discarded.
    RULE:
        The peer sending this method MAY use a counter or timeout
        to detect failure of the other peer to respond correctly
        with the Close-OK method.
    RULE:
        When a server receives the Close method from a client it
        MUST delete all server-side resources associated with the
        client's context.  A client CANNOT reconnect to a context
        after sending or receiving a Close method.
    PARAMETERS:
        reply_code: short
            The reply code. The AMQ reply codes are defined in AMQ
            RFC 011.
        reply_text: shortstr
            The localised reply text.  This text can be logged as an
            aid to resolving issues.
        class_id: short
            failing method class
            When the close is provoked by a method exception, this
            is the class of the method.
        method_id: short
            failing method ID
            When the close is provoked by a method exception, this
            is the ID of the method.
    """
    if self.transport is None:
        # already closed
        return
    args = AMQPWriter()
    args.write_short(reply_code)
    args.write_shortstr(reply_text)
    args.write_short(method_sig[0])  # class_id
    args.write_short(method_sig[1])  # method_id
    try:
        self._send_method((10, 50), args)
        return self.wait(allowed_methods=[
            (10, 50),  # Connection.close
            (10, 51),  # Connection.close_ok
        ])
    except (socket.timeout, socket.error) as e:
        # no point in waiting anymore
        if isinstance(e, socket.timeout):
            try:
                self.sock.settimeout(0.1)
            except:
                pass
        # lack of communication should not prevent tidy-up
        self._do_close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.dispatch_method">
    <p>def <span class="ident">dispatch_method</span>(</p><p>self, method_sig, args, content)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.dispatch_method', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.dispatch_method" class="source">
    <pre><code>def dispatch_method(self, method_sig, args, content):
    if content and \
            self.auto_encode_decode and \
            hasattr(content, 'content_encoding'):
        try:
            content.body = content.body.decode(content.content_encoding)
        except Exception:
            pass
    try:
        amqp_method = self._METHOD_MAP[method_sig]
    except KeyError:
        raise AMQPNotImplementedError(
            'Unknown AMQP method {0!r}'.format(method_sig))
    if content is None:
        return amqp_method(self, args)
    else:
        return amqp_method(self, args, content)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.drain_events">
    <p>def <span class="ident">drain_events</span>(</p><p>self, timeout=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for an event on a channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.drain_events', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.drain_events" class="source">
    <pre><code>def drain_events(self, timeout=None):
    """Wait for an event on a channel."""
    chanmap = self.channels
    chanid, method_sig, args, content = self._wait_multiple(
        chanmap, None, timeout=timeout,
    )
    channel = chanmap[chanid]
    if (content and
            channel.auto_encode_decode and
            hasattr(content, 'content_encoding')):
        try:
            content.body = content.body.decode(content.content_encoding)
        except Exception:
            pass
    amqp_method = (self._method_override.get(method_sig) or
                   channel._METHOD_MAP.get(method_sig, None))
    if amqp_method is None:
        raise AMQPNotImplementedError(
            'Unknown AMQP method {0!r}'.format(method_sig))
    if content is None:
        return amqp_method(channel, args)
    else:
        return amqp_method(channel, args, content)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.heartbeat_tick">
    <p>def <span class="ident">heartbeat_tick</span>(</p><p>self, rate=2)</p>
    </div>
    

    
  
    <div class="desc"><p>Send heartbeat packets, if necessary, and fail if none have been
received recently.  This should be called frequently, on the order of
once per second.</p>
<p>:keyword rate: Ignored</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.heartbeat_tick', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.heartbeat_tick" class="source">
    <pre><code>def heartbeat_tick(self, rate=2):
    """Send heartbeat packets, if necessary, and fail if none have been
    received recently.  This should be called frequently, on the order of
    once per second.
    :keyword rate: Ignored
    """
    if not self.heartbeat:
        return
    # treat actual data exchange in either direction as a heartbeat
    sent_now = self.method_writer.bytes_sent
    recv_now = self.method_reader.bytes_recv
    if self.prev_sent is None or self.prev_sent != sent_now:
        self.last_heartbeat_sent = monotonic()
    if self.prev_recv is None or self.prev_recv != recv_now:
        self.last_heartbeat_received = monotonic()
    self.prev_sent, self.prev_recv = sent_now, recv_now
    # send a heartbeat if it's time to do so
    if monotonic() > self.last_heartbeat_sent + self.heartbeat:
        self.send_heartbeat()
        self.last_heartbeat_sent = monotonic()
    # if we've missed two intervals' heartbeats, fail; this gives the
    # server enough time to send heartbeats a little late
    if (self.last_heartbeat_received and
            self.last_heartbeat_received + 2 *
            self.heartbeat < monotonic()):
        raise ConnectionForced('Too many heartbeats missed')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.is_alive">
    <p>def <span class="ident">is_alive</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.is_alive', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.is_alive" class="source">
    <pre><code>def is_alive(self):
    if HAS_MSG_PEEK:
        sock = self.sock
        prev = sock.gettimeout()
        sock.settimeout(0.0001)
        try:
            sock.recv(1, socket.MSG_PEEK)
        except socket.timeout:
            pass
        except socket.error:
            return False
        finally:
            sock.settimeout(prev)
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.read_timeout">
    <p>def <span class="ident">read_timeout</span>(</p><p>self, timeout=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.read_timeout', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.read_timeout" class="source">
    <pre><code>def read_timeout(self, timeout=None):
    if timeout is None:
        return self.method_reader.read_method()
    sock = self.sock
    prev = sock.gettimeout()
    if prev != timeout:
        sock.settimeout(timeout)
    try:
        try:
            return self.method_reader.read_method()
        except SSLError as exc:
            # http://bugs.python.org/issue10272
            if 'timed out' in str(exc):
                raise socket.timeout()
            # Non-blocking SSL sockets can throw SSLError
            if 'The operation did not complete' in str(exc):
                raise socket.timeout()
            raise
    finally:
        if prev != timeout:
            sock.settimeout(prev)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.send_heartbeat">
    <p>def <span class="ident">send_heartbeat</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.send_heartbeat', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.send_heartbeat" class="source">
    <pre><code>def send_heartbeat(self):
    self.transport.write_frame(8, 0, bytes())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Connection.wait">
    <p>def <span class="ident">wait</span>(</p><p>self, allowed_methods=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for a method that matches our allowed_methods parameter (the
default value of None means match any method), and dispatch to it.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Connection.wait', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Connection.wait" class="source">
    <pre><code>def wait(self, allowed_methods=None):
    """Wait for a method that matches our allowed_methods parameter (the
    default value of None means match any method), and dispatch to it."""
    method_sig, args, content = self.connection._wait_method(
        self.channel_id, allowed_methods)
    return self.dispatch_method(method_sig, args, content)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.channel_max" class="name">var <span class="ident">channel_max</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.channels" class="name">var <span class="ident">channels</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.client_heartbeat" class="name">var <span class="ident">client_heartbeat</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.confirm_publish" class="name">var <span class="ident">confirm_publish</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.connected" class="name">var <span class="ident">connected</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.frame_max" class="name">var <span class="ident">frame_max</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.locales" class="name">var <span class="ident">locales</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.mechanisms" class="name">var <span class="ident">mechanisms</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.method_reader" class="name">var <span class="ident">method_reader</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.method_writer" class="name">var <span class="ident">method_writer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.on_blocked" class="name">var <span class="ident">on_blocked</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.on_unblocked" class="name">var <span class="ident">on_unblocked</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.server_capabilities" class="name">var <span class="ident">server_capabilities</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.server_properties" class="name">var <span class="ident">server_properties</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.sock" class="name">var <span class="ident">sock</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.transport" class="name">var <span class="ident">transport</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.version_major" class="name">var <span class="ident">version_major</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Connection.version_minor" class="name">var <span class="ident">version_minor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ConnectionError" class="name">class <span class="ident">ConnectionError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ConnectionError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ConnectionError" class="source">
    <pre><code>class ConnectionError(AMQPError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConnectionError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConnectionError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ConnectionError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ConnectionError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ConnectionError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConnectionError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ConnectionForced" class="name">class <span class="ident">ConnectionForced</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ConnectionForced', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ConnectionForced" class="source">
    <pre><code>class ConnectionForced(RecoverableConnectionError):
    code = 320
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ConnectionForced">ConnectionForced</a></li>
          <li><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConnectionForced.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConnectionForced.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ConnectionForced.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ConnectionForced.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ConnectionForced.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConnectionForced.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.RecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ConsumerCancelled" class="name">class <span class="ident">ConsumerCancelled</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ConsumerCancelled', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ConsumerCancelled" class="source">
    <pre><code>class ConsumerCancelled(RecoverableConnectionError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ConsumerCancelled">ConsumerCancelled</a></li>
          <li><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConsumerCancelled.args" class="name">var <span class="ident">args</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.args">args</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConsumerCancelled.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ConsumerCancelled.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ConsumerCancelled.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ConsumerCancelled.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ConsumerCancelled.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.RecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ContentTooLarge" class="name">class <span class="ident">ContentTooLarge</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ContentTooLarge', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ContentTooLarge" class="source">
    <pre><code>class ContentTooLarge(RecoverableChannelError):
    code = 311
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ContentTooLarge">ContentTooLarge</a></li>
          <li><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ContentTooLarge.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ContentTooLarge.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ContentTooLarge.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ContentTooLarge.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ContentTooLarge.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ContentTooLarge.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.RecoverableChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.FrameError" class="name">class <span class="ident">FrameError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.FrameError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.FrameError" class="source">
    <pre><code>class FrameError(IrrecoverableConnectionError):
    code = 501
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.FrameError">FrameError</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.FrameError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.FrameError.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.FrameError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.FrameError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.FrameError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.FrameError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.FrameSyntaxError" class="name">class <span class="ident">FrameSyntaxError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.FrameSyntaxError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.FrameSyntaxError" class="source">
    <pre><code>class FrameSyntaxError(IrrecoverableConnectionError):
    code = 502
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.FrameSyntaxError">FrameSyntaxError</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.FrameSyntaxError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.FrameSyntaxError.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.FrameSyntaxError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.FrameSyntaxError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.FrameSyntaxError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.FrameSyntaxError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.InternalError" class="name">class <span class="ident">InternalError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.InternalError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.InternalError" class="source">
    <pre><code>class InternalError(IrrecoverableConnectionError):
    code = 541
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.InternalError">InternalError</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.InternalError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.InternalError.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.InternalError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.InternalError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.InternalError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.InternalError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.InvalidCommand" class="name">class <span class="ident">InvalidCommand</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.InvalidCommand', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.InvalidCommand" class="source">
    <pre><code>class InvalidCommand(IrrecoverableConnectionError):
    code = 503
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.InvalidCommand">InvalidCommand</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.InvalidCommand.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.InvalidCommand.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.InvalidCommand.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.InvalidCommand.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.InvalidCommand.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.InvalidCommand.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.InvalidPath" class="name">class <span class="ident">InvalidPath</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.InvalidPath', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.InvalidPath" class="source">
    <pre><code>class InvalidPath(IrrecoverableConnectionError):
    code = 402
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.InvalidPath">InvalidPath</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.InvalidPath.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.InvalidPath.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.InvalidPath.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.InvalidPath.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.InvalidPath.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.InvalidPath.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.IrrecoverableChannelError" class="name">class <span class="ident">IrrecoverableChannelError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.IrrecoverableChannelError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.IrrecoverableChannelError" class="source">
    <pre><code>class IrrecoverableChannelError(ChannelError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.IrrecoverableChannelError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.IrrecoverableChannelError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.IrrecoverableChannelError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.IrrecoverableChannelError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.IrrecoverableChannelError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.IrrecoverableChannelError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.IrrecoverableConnectionError" class="name">class <span class="ident">IrrecoverableConnectionError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.IrrecoverableConnectionError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.IrrecoverableConnectionError" class="source">
    <pre><code>class IrrecoverableConnectionError(ConnectionError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.IrrecoverableConnectionError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.IrrecoverableConnectionError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.IrrecoverableConnectionError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.IrrecoverableConnectionError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.IrrecoverableConnectionError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.IrrecoverableConnectionError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.Message" class="name">class <span class="ident">Message</span></p>
      
  
    <div class="desc"><p>A Message for use with the Channnel.basic_* methods.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Message', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Message" class="source">
    <pre><code>class Message(GenericContent):
    """A Message for use with the Channnel.basic_* methods."""

    #: Instances of this class have these attributes, which
    #: are passed back and forth as message properties between
    #: client and server
    PROPERTIES = [
        ('content_type', 'shortstr'),
        ('content_encoding', 'shortstr'),
        ('application_headers', 'table'),
        ('delivery_mode', 'octet'),
        ('priority', 'octet'),
        ('correlation_id', 'shortstr'),
        ('reply_to', 'shortstr'),
        ('expiration', 'shortstr'),
        ('message_id', 'shortstr'),
        ('timestamp', 'timestamp'),
        ('type', 'shortstr'),
        ('user_id', 'shortstr'),
        ('app_id', 'shortstr'),
        ('cluster_id', 'shortstr')
    ]

    def __init__(self, body='', children=None, channel=None, **properties):
        """Expected arg types

            body: string
            children: (not supported)

        Keyword properties may include:

            content_type: shortstr
                MIME content type

            content_encoding: shortstr
                MIME content encoding

            application_headers: table
                Message header field table, a dict with string keys,
                and string | int | Decimal | datetime | dict values.

            delivery_mode: octet
                Non-persistent (1) or persistent (2)

            priority: octet
                The message priority, 0 to 9

            correlation_id: shortstr
                The application correlation identifier

            reply_to: shortstr
                The destination to reply to

            expiration: shortstr
                Message expiration specification

            message_id: shortstr
                The application message identifier

            timestamp: datetime.datetime
                The message timestamp

            type: shortstr
                The message type name

            user_id: shortstr
                The creating user id

            app_id: shortstr
                The creating application id

            cluster_id: shortstr
                Intra-cluster routing identifier

        Unicode bodies are encoded according to the 'content_encoding'
        argument. If that's None, it's set to 'UTF-8' automatically.

        example::

            msg = Message('hello world',
                            content_type='text/plain',
                            application_headers={'foo': 7})

        """
        super(Message, self).__init__(**properties)
        self.body = body
        self.channel = channel

    def __eq__(self, other):
        """Check if the properties and bodies of this Message and another
        Message are the same.

        Received messages may contain a 'delivery_info' attribute,
        which isn't compared.

        """
        try:
            return (super(Message, self).__eq__(other) and
                    self.body == other.body)
        except AttributeError:
            return NotImplemented
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.Message">Message</a></li>
          <li>IoticAgent.third.amqp.serialization.GenericContent</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.Message.PROPERTIES" class="name">var <span class="ident">PROPERTIES</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.Message.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, body=&#39;&#39;, children=None, channel=None, **properties)</p>
    </div>
    

    
  
    <div class="desc"><p>Expected arg types</p>
<pre><code>body: string
children: (not supported)
</code></pre>
<p>Keyword properties may include:</p>
<pre><code>content_type: shortstr
    MIME content type

content_encoding: shortstr
    MIME content encoding

application_headers: table
    Message header field table, a dict with string keys,
    and string | int | Decimal | datetime | dict values.

delivery_mode: octet
    Non-persistent (1) or persistent (2)

priority: octet
    The message priority, 0 to 9

correlation_id: shortstr
    The application correlation identifier

reply_to: shortstr
    The destination to reply to

expiration: shortstr
    Message expiration specification

message_id: shortstr
    The application message identifier

timestamp: datetime.datetime
    The message timestamp

type: shortstr
    The message type name

user_id: shortstr
    The creating user id

app_id: shortstr
    The creating application id

cluster_id: shortstr
    Intra-cluster routing identifier
</code></pre>
<p>Unicode bodies are encoded according to the 'content_encoding'
argument. If that's None, it's set to 'UTF-8' automatically.</p>
<p>example::</p>
<pre><code>msg = Message('hello world',
                content_type='text/plain',
                application_headers={'foo': 7})
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.Message.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.Message.__init__" class="source">
    <pre><code>def __init__(self, body='', children=None, channel=None, **properties):
    """Expected arg types
        body: string
        children: (not supported)
    Keyword properties may include:
        content_type: shortstr
            MIME content type
        content_encoding: shortstr
            MIME content encoding
        application_headers: table
            Message header field table, a dict with string keys,
            and string | int | Decimal | datetime | dict values.
        delivery_mode: octet
            Non-persistent (1) or persistent (2)
        priority: octet
            The message priority, 0 to 9
        correlation_id: shortstr
            The application correlation identifier
        reply_to: shortstr
            The destination to reply to
        expiration: shortstr
            Message expiration specification
        message_id: shortstr
            The application message identifier
        timestamp: datetime.datetime
            The message timestamp
        type: shortstr
            The message type name
        user_id: shortstr
            The creating user id
        app_id: shortstr
            The creating application id
        cluster_id: shortstr
            Intra-cluster routing identifier
    Unicode bodies are encoded according to the 'content_encoding'
    argument. If that's None, it's set to 'UTF-8' automatically.
    example::
        msg = Message('hello world',
                        content_type='text/plain',
                        application_headers={'foo': 7})
    """
    super(Message, self).__init__(**properties)
    self.body = body
    self.channel = channel
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.Message.body" class="name">var <span class="ident">body</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.Message.channel" class="name">var <span class="ident">channel</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.NoConsumers" class="name">class <span class="ident">NoConsumers</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.NoConsumers', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.NoConsumers" class="source">
    <pre><code>class NoConsumers(RecoverableChannelError):
    code = 313
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.NoConsumers">NoConsumers</a></li>
          <li><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.NoConsumers.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.NoConsumers.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.NoConsumers.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.NoConsumers.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.NoConsumers.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.NoConsumers.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.RecoverableChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.NotAllowed" class="name">class <span class="ident">NotAllowed</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.NotAllowed', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.NotAllowed" class="source">
    <pre><code>class NotAllowed(IrrecoverableConnectionError):
    code = 530
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.NotAllowed">NotAllowed</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.NotAllowed.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.NotAllowed.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.NotAllowed.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.NotAllowed.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.NotAllowed.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.NotAllowed.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.NotFound" class="name">class <span class="ident">NotFound</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.NotFound', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.NotFound" class="source">
    <pre><code>class NotFound(IrrecoverableChannelError):
    code = 404
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.NotFound">NotFound</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.NotFound.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.NotFound.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.NotFound.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.NotFound.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.NotFound.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.NotFound.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.PreconditionFailed" class="name">class <span class="ident">PreconditionFailed</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.PreconditionFailed', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.PreconditionFailed" class="source">
    <pre><code>class PreconditionFailed(IrrecoverableChannelError):
    code = 406
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.PreconditionFailed">PreconditionFailed</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.PreconditionFailed.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.PreconditionFailed.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.PreconditionFailed.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.PreconditionFailed.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.PreconditionFailed.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.PreconditionFailed.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableChannelError">IrrecoverableChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.RecoverableChannelError" class="name">class <span class="ident">RecoverableChannelError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.RecoverableChannelError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.RecoverableChannelError" class="source">
    <pre><code>class RecoverableChannelError(ChannelError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.RecoverableChannelError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.RecoverableChannelError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.RecoverableChannelError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.RecoverableChannelError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.RecoverableChannelError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.RecoverableChannelError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.RecoverableConnectionError" class="name">class <span class="ident">RecoverableConnectionError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.RecoverableConnectionError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.RecoverableConnectionError" class="source">
    <pre><code>class RecoverableConnectionError(ConnectionError):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.RecoverableConnectionError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.RecoverableConnectionError.code" class="name">var <span class="ident">code</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.RecoverableConnectionError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.RecoverableConnectionError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.RecoverableConnectionError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.RecoverableConnectionError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ResourceError" class="name">class <span class="ident">ResourceError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ResourceError', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ResourceError" class="source">
    <pre><code>class ResourceError(RecoverableConnectionError):
    code = 506
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ResourceError">ResourceError</a></li>
          <li><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ResourceError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ResourceError.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ResourceError.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ResourceError.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ResourceError.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ResourceError.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.RecoverableConnectionError">RecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.RecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.ResourceLocked" class="name">class <span class="ident">ResourceLocked</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ResourceLocked', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ResourceLocked" class="source">
    <pre><code>class ResourceLocked(RecoverableChannelError):
    code = 405
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.ResourceLocked">ResourceLocked</a></li>
          <li><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ResourceLocked.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.ResourceLocked.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ChannelError">ChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.ChannelError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.ResourceLocked.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.ResourceLocked.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.ResourceLocked.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.ResourceLocked.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.RecoverableChannelError">RecoverableChannelError</a></code>.<code><a href="#IoticAgent.third.amqp.RecoverableChannelError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="IoticAgent.third.amqp.UnexpectedFrame" class="name">class <span class="ident">UnexpectedFrame</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.UnexpectedFrame', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.UnexpectedFrame" class="source">
    <pre><code>class UnexpectedFrame(IrrecoverableConnectionError):
    code = 505
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#IoticAgent.third.amqp.UnexpectedFrame">UnexpectedFrame</a></li>
          <li><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></li>
          <li><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.UnexpectedFrame.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="IoticAgent.third.amqp.UnexpectedFrame.code" class="name">var <span class="ident">code</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.ConnectionError">ConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.ConnectionError.code">code</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="IoticAgent.third.amqp.UnexpectedFrame.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, reply_text=None, method_sig=None, method_name=None, reply_code=None)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.AMQPError">AMQPError</a></code>.<code><a href="#IoticAgent.third.amqp.AMQPError.__init__">__init__</a></code>
    </p>

    
  
    <div class="desc inherited"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-IoticAgent.third.amqp.UnexpectedFrame.__init__', this);">Show source &equiv;</a></p>
  <div id="source-IoticAgent.third.amqp.UnexpectedFrame.__init__" class="source">
    <pre><code>def __init__(self, reply_text=None, method_sig=None,
             method_name=None, reply_code=None):
    self.message = reply_text
    self.reply_code = reply_code or self.code
    self.reply_text = reply_text
    self.method_sig = method_sig
    self.method_name = method_name or ''
    if method_sig and not self.method_name:
        self.method_name = METHOD_NAME_MAP.get(method_sig, '')
    Exception.__init__(self, reply_code,
                       reply_text, method_sig, self.method_name)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="IoticAgent.third.amqp.UnexpectedFrame.method" class="name">var <span class="ident">method</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError">IrrecoverableConnectionError</a></code>.<code><a href="#IoticAgent.third.amqp.IrrecoverableConnectionError.method">method</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
